---
title: "Sorghum and Rye Project: Final Figures and Tables"
format: 
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    code-overflow: wrap
    fig-width: 10
    fig-height: 6
    embed-resources: true
    theme: default
execute:
  echo: true
  warning: false
  message: false
  error: false
  cache: false
---

# Setup and Data Loading

```{r setup}
#| message: false
#| warning: false

# Load required packages
library(tidyverse)
library(lubridate)
library(gt)
library(janitor)
library(broom)
library(readxl)
library(patchwork)
library(multcompView)
library(emmeans)

# Re-establish dplyr preferences after loading packages
if (requireNamespace("conflicted", quietly = TRUE)) {
  library(conflicted)
  conflicts_prefer(dplyr::select)
  conflicts_prefer(dplyr::filter)
  conflicts_prefer(dplyr::summarise)
}

# Custom theme for consistency
theme_publication <- function(base_size = 12) {
  theme_minimal(base_size = base_size) +
    theme(
      panel.background = element_rect(fill = "#ffffffff", color = NA),
      plot.background = element_rect(fill = "#ffffffff", color = NA),
      panel.grid.major = element_line(color = alpha("#B7B5B3", 0.2)),
      panel.grid.minor = element_blank(),
      text = element_text(color = "#000000ff"),
      axis.text = element_text(color = "#000000ff"),
      strip.background = element_rect(fill = alpha("#A5CAD2", 0.2)),
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.spacing = unit(2, "lines")
    )
}

# Treatment colors
treatment_colors <- c(
  "Sorghum" = "#D8D97AFF",
  "Sorghum + Rye" = "#95C36EFF", 
  "Corn" = "#74C8C3FF",
  "Soy" = "#0A2E57FF"
)

scale_color_treatments <- function() scale_color_manual(values = treatment_colors)
scale_fill_treatments <- function() scale_fill_manual(values = treatment_colors)
```

# Data Import and Processing

```{r data-import}
#| message: false

# Import soil nitrogen data
# Nitrate and ammonia in ppm, not sure if moisture corrected
soil_data <- read_csv("data/soils/cleaned_soil_data.csv") %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(
    date = as.Date(date),
    total_inorganic_n = ammonia_ppm + nitrate_ppm
  ) 

# Import flux data 
# N2O flux in g N ha-1 day-1 
flux_data <- read_csv("data/cleaned_flux_data.csv") %>%
  mutate(date = as.Date(date)) 

# Import nitrogen leaching data
# Cumulative N loss in mg per day, same for nitrate and ammonium
leaching_data <- read_csv("data/clean_leaching.csv") %>%
  clean_names() %>%
  mutate(
    date = as.Date(date),
    year = year(date)
  ) %>%
  filter(year %in% c(2023, 2024)) %>%  # Filter out bad years
  filter(!is.na(year))

# Import historical rain and gdd data
gdd <- read_xlsx("data/rain/historical_rain.xlsx")

gdd <- gdd %>%
  select(day, doy, gdd_50_86) %>%
  mutate(
    date = as.Date(day),
    year = year(date),
  ) %>%
  group_by(year) %>%
  arrange(date) %>%
  mutate(cumulative_gdd = cumsum(gdd_50_86))

gdd <- gdd %>%
  mutate(doy_date = as.Date(doy - 1, origin = "2000-01-01"))

rain <- read_xlsx("data/rain/historical_rain.xlsx")

rain <- rain %>%
  select(day, doy, precipmm) %>%
  mutate(
    date = as.Date(day),
    year = year(date),
  ) %>%
  group_by(year) %>%
  arrange(date) %>%
  mutate(cumulative_precip = cumsum(precipmm))

rain <- rain %>%
  mutate(doy_date = as.Date(doy - 1, origin = "2000-01-01"))
```

# Helper Functions

```{r helper-functions}
# Function for pairwise t-tests within groups
#| label: get-pvals
get_pairwise_pvals <- function(data, variable, group_vars) {
  data %>%
    group_by(across(all_of(group_vars))) %>%
    group_modify(~ {
      treatments <- unique(.x$treatment)
      if (length(treatments) < 2) {
        return(tibble(p_value = NA_real_))
      }
      
      if (length(treatments) == 2) {
        t_result <- t.test(.x[[variable]][.x$treatment == treatments[1]], 
                          .x[[variable]][.x$treatment == treatments[2]])
        return(tibble(p_value = t_result$p.value))
      } else {
        pairwise_result <- pairwise.t.test(.x[[variable]], .x$treatment, 
                                          p.adjust.method = "none")
        return(tibble(p_value = min(pairwise_result$p.value, na.rm = TRUE)))
      }
    }) %>%
    ungroup()
}

# Function to add significance letters
add_significance_letters <- function(data, p_col) {
  data %>%
    mutate(
      significance_letter = case_when(
        is.na({{ p_col }}) ~ "",
        {{ p_col }} < 0.001 ~ "a",
        {{ p_col }} < 0.01 ~ "b", 
        {{ p_col }} < 0.05 ~ "c",
        TRUE ~ ""
      ),
      result_with_sig = if_else(
        significance_letter == "", 
        result,
        paste0(result, " ", significance_letter)
      )
    )
}

# Function to create ANOVA source tables
create_source_table <- function(model_results) {
  tibble(
    source = c("Date", "Treatment", "Date × Treatment"),
    p_value = summary(model_results)[[1]][c(2, 3, 6), "Pr(>F)"]
  ) %>%
    mutate(
      formatted_p = case_when(
        p_value < 0.001 ~ "< 0.001",
        p_value < 0.01 ~ sprintf("%.3f", p_value),
        TRUE ~ sprintf("%.2f", p_value)
      )
    )
}
```

# Table 1: Soil Properties

```{r}
# Table 1: Soil Properties
# column names Soil Property, Sorghum, Sorghum + Rye
colnames <- c("Soil Property", "Sorghum", "Sorghum + Rye")
rows <- c("Soil Series", "Texture", "pH", "Soil Organic Matter (%)")


```

# Table 2: Salt-extractable Inorganic Nitrogen

```{r table-2}
#| label: tbl-soil-nitrogen
#| tbl-cap: "Salt-extractable inorganic nitrogen"

# Calculate summary statistics
soil_summary <- soil_data %>%
  group_by(year, date, treatment) %>%
  summarise(
    across(c(ammonia_ppm, nitrate_ppm, total_inorganic_n), 
           list(mean = ~ mean(.x, na.rm = TRUE),
                se = ~ sd(.x, na.rm = TRUE) / sqrt(sum(!is.na(.x))))),
    .groups = "drop"
  ) 

# Get p-values for pairwise comparisons
pvals_ammonium <- get_pairwise_pvals(soil_data, "ammonia_ppm", c("year", "date"))
pvals_nitrate <- get_pairwise_pvals(soil_data, "nitrate_ppm", c("year", "date"))  
pvals_total_n <- get_pairwise_pvals(soil_data, "total_inorganic_n", c("year", "date"))

# Combine with p-values and format
soil_table_data <- soil_summary %>%
  left_join(pvals_ammonium %>% rename(ammonia_p = p_value), by = c("year", "date")) %>%
  left_join(pvals_nitrate %>% rename(nitrate_p = p_value), by = c("year", "date")) %>%
  left_join(pvals_total_n %>% rename(total_n_p = p_value), by = c("year", "date")) %>%
  pivot_longer(
    cols = c(ammonia_ppm_mean, ammonia_ppm_se, nitrate_ppm_mean, nitrate_ppm_se, 
             total_inorganic_n_mean, total_inorganic_n_se),
    names_to = c("variable", "stat"),
    names_pattern = "(.*)_(mean|se)",
    values_to = "value"
  ) %>%
  pivot_wider(names_from = stat, values_from = value) %>%
  mutate(
    result = sprintf("%.2f ± %.2f", mean, se),
    p_val = case_when(
      variable == "ammonia_ppm" ~ ammonia_p,
      variable == "nitrate_ppm" ~ nitrate_p,
      variable == "total_inorganic_n" ~ total_n_p
    ),
    variable = case_when(
      variable == "ammonia_ppm" ~ "ammonium",
      variable == "nitrate_ppm" ~ "nitrate", 
      variable == "total_inorganic_n" ~ "total_n"
    )
  ) %>%
  add_significance_letters(p_val) %>%
  select(year, date, treatment, variable, result_with_sig) %>%
  pivot_wider(names_from = variable, values_from = result_with_sig)

# Format dates and years for display
soil_table_formatted <- soil_table_data %>%
  mutate(
    year = as.character(year),
    date = format(as.Date(date), "%B %d")
  ) %>%
  arrange(year, as.Date(paste(year, date), format = "%Y %B %d"), treatment) %>%
  group_by(year) %>%
  mutate(
    year_display = if_else(row_number() == 1, year, ""),
    is_new_date = date != lag(date, default = "")
  ) %>%
  ungroup()

# Create ANOVA source of variation
aov_ammonium <- aov(ammonia_ppm ~ year * date * treatment, data = soil_data)
aov_nitrate <- aov(nitrate_ppm ~ year * date * treatment, data = soil_data)
aov_total_n <- aov(total_inorganic_n ~ year * date * treatment, data = soil_data)

source_variation <- tibble(
  source = c("Date", "Treatment", "Date × Treatment"),
  ammonium = summary(aov_ammonium)[[1]][c(2, 3, 6), "Pr(>F)"],
  nitrate = summary(aov_nitrate)[[1]][c(2, 3, 6), "Pr(>F)"],
  total_n = summary(aov_total_n)[[1]][c(2, 3, 6), "Pr(>F)"]
) %>%
  mutate(across(c(ammonium, nitrate, total_n), ~ case_when(
    .x < 0.001 ~ "< 0.001",
    .x < 0.01 ~ sprintf("%.3f", .x),
    TRUE ~ sprintf("%.2f", .x)
  ))) %>%
  mutate(
    year_display = "",
    date = "",
    treatment = source,
    .before = 1
  ) %>%
  select(-source)

# Combine data with source of variation
separator_row <- tibble(
  year_display = "Source of Variation", date = "", treatment = "",
  ammonium = "", nitrate = "", total_n = "", is_new_date = FALSE
)

table2_complete <- bind_rows(
  soil_table_formatted,
  separator_row,
  source_variation %>% mutate(is_new_date = FALSE)
)

# Create gt table
table2_gt <- table2_complete %>%
  select(-year) %>%
  select(year_display, date, treatment, ammonium, nitrate, total_n, is_new_date) %>%
  gt() %>%
  tab_header(title = md("**Table 2. Salt-extractable inorganic nitrogen**")) %>%
  cols_label(
    year_display = "Year",
    date = "Date", 
    treatment = "Treatment",
    ammonium = md("Ammonium<br>(mg kg<sup>-1</sup>)"),
    nitrate = md("Nitrate<br>(mg kg<sup>-1</sup>)"),
    total_n = md("Total Inorganic N<br>(mg kg<sup>-1</sup>)")
  ) %>%
  tab_style(
    style = cell_borders(sides = "top", weight = px(1), color = "gray"),
    locations = cells_body(rows = is_new_date == TRUE)
  ) %>%
  tab_style(
    style = cell_borders(sides = "top", weight = px(2)),
    locations = cells_body(rows = year_display == "Source of Variation")
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(rows = year_display == "Source of Variation")
  ) %>%
  tab_style(
    style = cell_text(align = "center", weight = "bold"),
    locations = cells_body(columns = year_display, rows = year_display == "Source of Variation")
  ) %>%
  cols_hide(columns = is_new_date) %>%
  tab_footnote(
    footnote = "Letters indicate significance levels: a = p < 0.001, b = p < 0.01, c = p < 0.05",
    locations = cells_title()
  )

# Save table
gtsave(table2_gt, "tables/table2_soil_nitrogen.rtf")
# Save as .png for manuscript
gtsave(table2_gt, "tables/table2_soil_nitrogen.png")
table2_gt
```

# N2O Data Processing and Analysis

```{r n2o-processing}
# Process daily flux data with interpolation
daily_flux_summary <- flux_data %>%
  group_by(plot, rowvs_interrow, treatment, year, date) %>%
  summarise(mean_flux = mean(gnha_day_no_negative, na.rm = TRUE), .groups = "drop") %>%
  arrange(plot, rowvs_interrow, treatment, year, date)

# Interpolation function
interpolate_daily_flux <- function(data) {
  # Get unique plot combinations
  plot_combinations <- data %>%
    distinct(plot, rowvs_interrow, treatment, year)
  
  # Interpolate for each combination
  map_dfr(seq_len(nrow(plot_combinations)), function(i) {
    combo <- plot_combinations[i, ]
    
    subset_data <- data %>%
      filter(
        plot == combo$plot,
        rowvs_interrow == combo$rowvs_interrow,
        treatment == combo$treatment,
        year == combo$year
      ) %>%
      arrange(date)
    
    # Create full year sequence
    start_date <- as.Date(paste0(combo$year, "-01-01"))
    end_date <- as.Date(paste0(combo$year, "-12-31"))
    all_days <- seq(start_date, end_date, by = "day")
    
    # Interpolate if we have sufficient data
    if (nrow(subset_data) >= 2 && !all(is.na(subset_data$mean_flux))) {
      valid_data <- subset_data[!is.na(subset_data$mean_flux), ]
      
      if (nrow(valid_data) >= 2) {
        interpolated_flux <- approx(
          x = as.numeric(valid_data$date),
          y = valid_data$mean_flux,
          xout = as.numeric(all_days),
          rule = 1
        )$y
      } else {
        interpolated_flux <- rep(NA_real_, length(all_days))
      }
    } else {
      interpolated_flux <- rep(NA_real_, length(all_days))
    }
    
    tibble(
      plot = combo$plot,
      rowvs_interrow = combo$rowvs_interrow,
      treatment = combo$treatment,
      year = combo$year,
      date = all_days,
      interpolated_flux = interpolated_flux
    )
  })
}

# Apply interpolation
interpolated_flux_data <- interpolate_daily_flux(daily_flux_summary)

# Calculate cumulative N2O per plot
plot_cumulative_n2o <- interpolated_flux_data %>%
  group_by(plot, rowvs_interrow, treatment, year) %>%
  summarise(
    annual_cumulative_n2o = sum(interpolated_flux, na.rm = TRUE) / 1000, # Convert g to kg
    .groups = "drop"
  ) %>%
  filter(is.finite(annual_cumulative_n2o))

cat("✓ N2O interpolation and cumulative calculations complete\n")
cat("Plot-level cumulative N2O data:", nrow(plot_cumulative_n2o), "observations\n")
```

# Nitrogen Leaching Data Processing

```{r leaching-processing}
# Calculate annual cumulative nitrogen leaching per plot
# Convert mg per plot to kg N ha-1
plot_area_ft2 <- 120*160  # in ft^2
plot_area_ha <- plot_area_ft2 / 107639.1041671  # Convert ft^2 to ha
annual_leaching <- leaching_data %>%
  group_by(plot, treatment, year) %>%
  summarise(
    annual_cumulative_leaching = (max(cumulative_n_loss_mg, na.rm = TRUE) / 1000000) / plot_area_ha, # mg to kg to kg/ha
    .groups = "drop"
  ) %>%
  filter(is.finite(annual_cumulative_leaching), annual_cumulative_leaching >= 0)

cat("✓ Nitrogen leaching calculations complete\n")
cat("Plot-level leaching data:", nrow(annual_leaching), "observations\n")
```

# Table 3: Annual Nitrogen Losses

```{r}
# Summarize N2O data by treatment and year
n2o_summary <- plot_cumulative_n2o %>%
  group_by(treatment, year) %>%
  summarise(
    n_plots = n(),
    mean_n2o = mean(annual_cumulative_n2o, na.rm = TRUE),
    sd_n2o = sd(annual_cumulative_n2o, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(n2o_result = sprintf("%.3f ± %.3f", mean_n2o, sd_n2o))

# Summarize leaching data by treatment and year
leaching_summary <- annual_leaching %>%
  group_by(treatment, year) %>%
  summarise(
    n_plots = n(),
    mean_leaching = mean(annual_cumulative_leaching, na.rm = TRUE),
    sd_leaching = sd(annual_cumulative_leaching, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(leaching_result = sprintf("%.3f ± %.3f", mean_leaching, sd_leaching))

# Add per-year Tukey letters (within-year) for Leaching (and optionally N2O)
compute_letters_by_year <- function(df, value_col) {
  d <- df %>% filter(!is.na(.data[[value_col]]))
  trts <- sort(unique(d$treatment))
  if (length(trts) < 2) return(tibble(treatment = trts, letter = "a"))
  fml <- as.formula(paste(value_col, "~ treatment"))
  fit <- lm(fml, data = d)
  emm <- emmeans::emmeans(fit, ~ treatment)
  if (requireNamespace("multcomp", quietly = TRUE)) {
    out <- multcomp::cld(emm, adjust = "tukey", Letters = letters) %>%
      as_tibble() %>%
      transmute(treatment, letter = gsub("\\s+", "", .group)) %>%
      mutate(
        # If numbers slipped through, map 1->a, 2->b, etc., and combine (e.g., 12->ab)
        letter = ifelse(grepl("[0-9]", letter), chartr("123456789", "abcdefghi", letter), letter),
        letter = ifelse(letter == "" | is.na(letter), "a", letter)
      )
  } else {
    # Fallback: if Tukey letters cannot be computed, return all 'a'
    out <- tibble(treatment = trts, letter = rep("a", length(trts)))
  }
  out
}

leach_letters <- annual_leaching %>%
  group_by(year) %>%
  group_modify(~ compute_letters_by_year(.x, "annual_cumulative_leaching"))

# Optionally compute for N2O (will likely be all 'a' given ns per-year tests)
n2o_letters <- plot_cumulative_n2o %>%
  group_by(year) %>%
  group_modify(~ compute_letters_by_year(.x, "annual_cumulative_n2o"))

# Attach letters to per-year rows only (exclude 2023–2024 totals later)
leaching_summary <- leaching_summary %>%
  left_join(leach_letters, by = c("treatment", "year")) %>%
  mutate(leaching_result = if_else(year %in% c(2023, 2024) & !is.na(letter),
                                   sprintf("%.3f ± %.3f (%s)", mean_leaching, sd_leaching, letter),
                                   sprintf("%.3f ± %.3f", mean_leaching, sd_leaching))) %>%
  select(-letter)

n2o_summary <- n2o_summary %>%
  left_join(n2o_letters, by = c("treatment", "year")) %>%
  mutate(n2o_result = if_else(year %in% c(2023, 2024) & !is.na(letter),
                              sprintf("%.3f ± %.3f (%s)", mean_n2o, sd_n2o, letter),
                              sprintf("%.3f ± %.3f", mean_n2o, sd_n2o))) %>%
  select(-letter)

# Calculate 2-year totals (as sum of 2023 and 2024 per treatment)
# Mean = mean_2023 + mean_2024; SD via quadrature: sqrt(sd_2023^2 + sd_2024^2)
n2o_two_year <- n2o_summary %>%
  filter(year %in% c(2023, 2024)) %>%
  group_by(treatment) %>%
  summarise(
    mean_n2o = sum(mean_n2o, na.rm = TRUE),
    sd_n2o = sqrt(sum(sd_n2o^2, na.rm = TRUE)),
    .groups = "drop"
  ) %>%
  mutate(
    year = "2023-2024",
    n2o_result = sprintf("%.3f ± %.3f", mean_n2o, sd_n2o)
  )

leaching_two_year <- leaching_summary %>%
  filter(year %in% c(2023, 2024)) %>%
  group_by(treatment) %>%
  summarise(
    mean_leaching = sum(mean_leaching, na.rm = TRUE),
    sd_leaching = sqrt(sum(sd_leaching^2, na.rm = TRUE)),
    .groups = "drop"
  ) %>%
  mutate(
    year = "2023-2024", 
    leaching_result = sprintf("%.3f ± %.3f", mean_leaching, sd_leaching)
  )
compare_df_cols(n2o_two_year, leaching_two_year, n2o_summary, leaching_summary)

# Extract mean values for environmental cost calculation
n2o_means <- bind_rows(
  n2o_summary %>% mutate(year = as.character(year)) %>% select(year, treatment, mean_n2o),
  n2o_two_year %>% select(year, treatment, mean_n2o)
)

leaching_means <- bind_rows(
  leaching_summary %>% mutate(year = as.character(year)) %>% select(year, treatment, mean_leaching),
  leaching_two_year %>% select(year, treatment, mean_leaching)
)

# Combine annual and 2-year data
combined_nitrogen_data <- bind_rows(
  n2o_summary %>% mutate(year = as.character(year)) %>% select(year, treatment, n2o_result),
  n2o_two_year %>% select(year, treatment, n2o_result)
) %>%
  full_join(
    bind_rows(
      leaching_summary %>% mutate(year = as.character(year)) %>% select(year, treatment, leaching_result),
      leaching_two_year %>% select(year, treatment, leaching_result)
    ),
    by = c("year", "treatment")
  ) %>%
  # Join with mean values for cost calculation
  left_join(n2o_means, by = c("year", "treatment")) %>%
  left_join(leaching_means, by = c("year", "treatment")) %>%
  mutate(
    year_order = case_when(
      year == "2023" ~ 1,
      year == "2024" ~ 2,
      year == "2023-2024" ~ 3
    ),
    # Calculate total environmental cost: $16/kg N₂O + $20/kg N leached
    environmental_cost_dollars = (mean_n2o * 16.18) + (mean_leaching * 18.54), # Not run, Preza-Fontes values
    total_environmental_cost = sprintf("$%.2f", environmental_cost_dollars)
  ) %>%
  arrange(year_order, treatment)
# Only use nitrate for leaching? 
# Source of variation analysis
# N2O ANOVA
combined_n2o_data <- plot_cumulative_n2o %>% mutate(year_factor = as.factor(year))
aov_n2o <- aov(annual_cumulative_n2o ~ year_factor * treatment, data = combined_n2o_data)

# Leaching ANOVA  
combined_leaching_data <- annual_leaching %>% mutate(year_factor = as.factor(year))
aov_leaching <- aov(annual_cumulative_leaching ~ year_factor * treatment, data = combined_leaching_data)

# Source of variation table
source_variation_n <- tibble(
  source = c("Year", "Treatment", "Year × Treatment"),
  n2o_p = summary(aov_n2o)[[1]][1:3, "Pr(>F)"],
  leaching_p = summary(aov_leaching)[[1]][1:3, "Pr(>F)"]
) %>%
  mutate(
    across(c(n2o_p, leaching_p), ~ case_when(
      .x < 0.001 ~ "< 0.001",
      .x < 0.01 ~ sprintf("%.3f", .x),
      TRUE ~ sprintf("%.2f", .x)
    )),
    year = "",
    year_order = 4,
    treatment = source,
    n2o_result = n2o_p,
    leaching_result = leaching_p,
    total_environmental_cost = "",  # No p-value for calculated cost
    mean_n2o = NA_real_,  # Add for consistency
    mean_leaching = NA_real_,  # Add for consistency
    environmental_cost_dollars = NA_real_  # Add for consistency
  ) %>%
  select(-source, -n2o_p, -leaching_p)

# Create complete table
separator_n <- tibble(
  year = "Source of Variation", year_order = 3.5, treatment = "",
  n2o_result = "", leaching_result = "", total_environmental_cost = "",
  mean_n2o = NA_real_, mean_leaching = NA_real_, environmental_cost_dollars = NA_real_
)

table3_complete <- bind_rows(
  combined_nitrogen_data,
  separator_n,
  source_variation_n
) %>%
  arrange(year_order, treatment) %>%
  mutate(
    year_display = case_when(
      year == "Source of Variation" ~ year,
      year != lag(year, default = "") ~ as.character(year),
      TRUE ~ ""
    ),
    is_new_section = year != lag(year, default = "") & year != "Source of Variation"
  )

# Create gt table
table3_gt <- table3_complete %>%
  select(
    Year = year_display,
    Treatment = treatment,
    `N2O Loss` = n2o_result,
    `N Leaching` = leaching_result, 
    `Total Environmental Cost` = total_environmental_cost,
    is_new_section
  ) %>%
  gt() %>%
  tab_header(title = md("**Table 3. Annual nitrogen losses**")) %>%
  cols_label(
    `N2O Loss` = md("N<sub>2</sub>O Loss<br>(kg N ha<sup>-1</sup>)"),
    `N Leaching` = md("N Leaching<br>(kg N ha<sup>-1</sup>)"),
    `Total Environmental Cost` = md("Total Environmental Cost<br>(USD ha<sup>-1</sup>)")
  ) %>%
  tab_style(
    style = cell_borders(sides = "top", weight = px(1), color = "gray"),
    locations = cells_body(rows = is_new_section == TRUE)
  ) %>%
  # Fix the gap by setting explicit column widths
  cols_width(
    Year ~ px(90),
    Treatment ~ px(150),
    `N2O Loss` ~ px(160),
    `N Leaching` ~ px(160),
    `Total Environmental Cost` ~ px(160)
  ) %>%
  # Optional: tighten padding and fix total table width
  tab_options(
    table.width = px(740),
    column_labels.padding = px(6),
    data_row.padding = px(6)
  ) %>%
  tab_style(
    style = cell_borders(sides = "top", weight = px(2)),
    locations = cells_body(rows = Year == "Source of Variation")
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(rows = Year == "Source of Variation")  
  ) %>%
  cols_hide(columns = is_new_section) %>%
  tab_footnote(
    footnote = "Values are mean ± standard deviation. Letters (in parentheses) indicate Tukey-adjusted groups within year (α = 0.05). Two-year totals (2023–2024) report sums; letters are not shown for totals. Environmental cost: $16/kg N₂O + $20/kg N leached.",
    locations = cells_title()
  )

# Save table
gtsave(table3_gt, "tables/table3_nitrogen_losses.rtf")
# Save as .png for manuscript
gtsave(table3_gt, "tables/table3_nitrogen_losses.png")
table3_gt
```

```{r diagnostics-fig4-table3-consistency}
# Verify Figure 4 means match Table 3 means for 2023 and 2024
fig4_means <- combined_loss %>%
  select(year, treatment, mean_leach, mean_n2o) %>% distinct()

tbl3_means <- bind_rows(
  leaching_summary %>% transmute(year, treatment, mean_leach = mean_leaching),
  n2o_summary %>% transmute(year, treatment, mean_n2o)
) %>%
  group_by(year, treatment) %>% summarise(
    mean_leach = max(mean_leach, na.rm = TRUE),
    mean_n2o = max(mean_n2o, na.rm = TRUE),
    .groups = "drop"
  )

consistency_check <- fig4_means %>%
  full_join(tbl3_means, by = c("year", "treatment"), suffix = c("_fig4", "_tbl3")) %>%
  mutate(
    match_leach = isTRUE(all.equal(mean_leach_fig4, mean_leach_tbl3, tolerance = 1e-8)),
    match_n2o = isTRUE(all.equal(mean_n2o_fig4, mean_n2o_tbl3, tolerance = 1e-8))
  )
print("Figure 4 vs Table 3 mean comparison (TRUE means match):")
print(consistency_check %>% select(year, treatment, match_leach, match_n2o))
```

```{r diagnostics-per-year-significance}
# Check per-year treatment differences (2023 and 2024 separately)
check_year_sig <- function(df, value_col, year_val) {
  d <- df %>% filter(year == year_val)
  fml <- as.formula(paste(value_col, "~ treatment"))
  fit <- aov(fml, data = d)
  p <- summary(fit)[[1]][["Pr(>F)"]][1]
  list(p_value = p)
}

res <- tibble(
  component = c("N2O", "N2O", "Leaching", "Leaching"),
  year = c(2023, 2024, 2023, 2024),
  p_value = c(
    check_year_sig(plot_cumulative_n2o, "annual_cumulative_n2o", 2023)$p_value,
    check_year_sig(plot_cumulative_n2o, "annual_cumulative_n2o", 2024)$p_value,
    check_year_sig(annual_leaching, "annual_cumulative_leaching", 2023)$p_value,
    check_year_sig(annual_leaching, "annual_cumulative_leaching", 2024)$p_value
  )
)
print("Per-year treatment ANOVA p-values (expect > 0.05 to indicate no significant differences):")
print(res)
```

**Table 3. Annual nitrogen losses by treatment.** Values are mean ± standard deviation. Letters indicate Tukey-adjusted significance groups; treatments sharing a letter are not significantly different ($\alpha=0.05$). Source of variation p-values are from ANOVA

```{r table-3}
#| label: tbl-nitrogen-losses
#| tbl-width: 10
#| tbl-height: 6
# ...existing code for combined_nitrogen_data and table rendering...
table3_complete <- bind_rows(
  combined_nitrogen_data,
  separator_n,
  source_variation_n
) %>%
  arrange(year_order, treatment) %>%
  mutate(
    year_display = case_when(
      year == "Source of Variation" ~ year,
      year != lag(year, default = "") ~ as.character(year),
      TRUE ~ ""
    ),
    is_new_section = year != lag(year, default = "") & year != "Source of Variation"
  )

# Create gt table
table3_gt <- table3_complete %>%
  select(
    Year = year_display,
    Treatment = treatment,
    `N2O Loss` = n2o_result,
    `N Leaching` = leaching_result, 
    `Total Environmental Cost` = total_environmental_cost,
    is_new_section
  ) %>%
  gt() %>%
  tab_header(title = md("**Table 3. Annual nitrogen losses**")) %>%
  cols_label(
    `N2O Loss` = md("N<sub>2</sub>O Loss<br>(kg N ha<sup>-1</sup>)"),
    `N Leaching` = md("N Leaching<br>(kg N ha<sup>-1</sup>)"),
    `Total Environmental Cost` = md("Total Environmental Cost<br>(USD ha<sup>-1</sup>)")
  ) %>%
  tab_style(
    style = cell_borders(sides = "top", weight = px(1), color = "gray"),
    locations = cells_body(rows = is_new_section == TRUE)
  ) %>%
  tab_style(
    style = cell_borders(sides = "top", weight = px(2)),
    locations = cells_body(rows = Year == "Source of Variation")
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(rows = Year == "Source of Variation")  
  ) %>%
  cols_hide(columns = is_new_section) %>%
  tab_footnote(
    footnote = "Values are mean ± standard deviation. Letters indicate significance levels: a = p < 0.001, b = p < 0.01, c = p < 0.05",
    locations = cells_title()
  )

# Save table
gtsave(table3_gt, "tables/table3_nitrogen_losses.rtf")

table3_gt
```

# Figure: test: Flow and Nitrogen Leaching Relationship

This will give a good idea of the variation between flow and nitrogen leaching across treatments and years.

```{r debug-leaching-data}
#| label: debug-leaching
#| echo: true

# Let's examine the leaching data structure to understand the issue
cat("=== LEACHING DATA STRUCTURE ===\n")
cat("Total rows in leaching_data:", nrow(leaching_data), "\n")
cat("Years present:", paste(sort(unique(leaching_data$year)), collapse = ", "), "\n")
cat("Treatments present:", paste(sort(unique(leaching_data$treatment)), collapse = ", "), "\n")
cat("Plots present:", paste(sort(unique(leaching_data$plot)), collapse = ", "), "\n\n")

# Check treatment-year combinations
cat("=== TREATMENT-YEAR COMBINATIONS ===\n")
treatment_year_summary <- leaching_data %>%
  group_by(year, treatment) %>%
  summarise(
    n_observations = n(),
    unique_plots = length(unique(plot)),
    plots = paste(sort(unique(plot)), collapse = ", "),
    .groups = "drop"
  ) %>%
  arrange(year, treatment)

print(treatment_year_summary)

# Check for potential data issues
cat("\n=== POTENTIAL ISSUES ===\n")
duplicate_check <- leaching_data %>%
  group_by(plot, treatment, year, date) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1)

if(nrow(duplicate_check) > 0) {
  cat("WARNING: Duplicate plot-treatment-year-date combinations found!\n")
  print(head(duplicate_check))
} else {
  cat("No duplicate plot-treatment-year-date combinations found.\n")
}

# Check if same plot appears in multiple treatments within same year
plot_treatment_check <- leaching_data %>%
  distinct(plot, treatment, year) %>%
  group_by(plot, year) %>%
  summarise(treatments = paste(sort(treatment), collapse = ", "), n_treatments = n(), .groups = "drop") %>%
  filter(n_treatments > 1)

if(nrow(plot_treatment_check) > 0) {
  cat("\nWARNING: Plots appear in multiple treatments within same year:\n")
  print(plot_treatment_check)
} else {
  cat("\nGood: Each plot has only one treatment per year.\n")
}
```

```{r figure-test}
#| label: fig-flow-leaching
#| fig-cap: "Annual tile drain flow and cumulative nitrogen losses by treatment"
#| fig-width: 10
#| fig-height: 6

# Calculate annual totals from leaching data - INDIVIDUAL PLOTS
plot_flow_n_data <- leaching_data %>%
  group_by(plot, treatment, year) %>%
  summarise(
    total_flow_L = sum(flow_l, na.rm = TRUE),  # Sum daily flow to get annual total
    total_n_loss_mg = max(cumulative_n_loss_mg, na.rm = TRUE),  # Use existing cumulative N
    .groups = "drop"
  ) %>%
  # Remove any infinite or negative values
  filter(is.finite(total_flow_L), is.finite(total_n_loss_mg), 
         total_flow_L >= 0, total_n_loss_mg >= 0) %>%
  # Create plot labels and grouping variables  
  mutate(
    plot_label = paste("Plot", plot),
    year_treatment = paste(year, treatment, sep = " "),
    treatment_year = paste(treatment, year, sep = "_"),
    # Create unique plot identifier within treatment-year
    plot_id = paste(plot, treatment, year, sep = "_")
  ) %>%
  # Arrange by treatment and year for better visual grouping
  arrange(year, treatment, plot)

# Check the data structure - should match expected sample sizes
cat("Plots per treatment-year combination:\n")
print(plot_flow_n_data %>% 
  group_by(year, treatment) %>% 
  summarise(n_plots = n(), plots = paste(sort(unique(plot)), collapse = ", "), .groups = "drop"))

# Create individual plot bars showing variation within treatments
flow_n_plot <- ggplot(plot_flow_n_data, aes(x = year_treatment, group = plot)) +
  # Flow bars for individual plots - side by side
  geom_col(aes(y = total_flow_L, fill = treatment), 
           position = position_dodge(width = 0.8), alpha = 0.8, width = 0.15) +
  # Nitrogen points (scaled to flow axis) for individual plots
  geom_point(aes(y = total_n_loss_mg * max(total_flow_L, na.rm = TRUE) / max(total_n_loss_mg, na.rm = TRUE), 
                 color = treatment), 
             position = position_dodge(width = 0.8), size = 4, shape = 18) +
  # Scales and formatting
  scale_fill_treatments() +
  scale_color_treatments() +
  scale_y_continuous(
    name = "Annual Tile Drain Flow (L)",
    labels = scales::comma,
    sec.axis = sec_axis(
      trans = ~ . * max(plot_flow_n_data$total_n_loss_mg, na.rm = TRUE) / max(plot_flow_n_data$total_flow_L, na.rm = TRUE),
      name = "Cumulative N Loss (mg)",
      labels = scales::comma
    )
  ) +
  labs(
    x = "Year and Treatment",
    fill = "Treatment",
    color = "Treatment"
  ) +
  theme_publication() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    legend.position = "bottom",
    plot.title = element_text(size = 14),
    plot.subtitle = element_text(size = 11, color = "gray40"),
    axis.title.y.right = element_text(angle = 90, vjust = 0.5),
    panel.grid.major.x = element_blank()
  ) +
  # Add subtle separators between treatment groups
  facet_grid(. ~ year, scales = "free_x", space = "free_x", 
             labeller = labeller(year = function(x) paste("Year", x)))

flow_n_plot

ggsave("figures/figuresupp1_flow_nitrogen_relationship.png", width = 10, height = 6, dpi = 300)
```

# Figure 1: Precipitation and Temperature

```{r figure-weather}
#| label: fig-weather
#| fig-cap: "Daily precipitation, temperature, and soil moisture over the study period"
#| fig-width: 10
#| fig-height: 6

# Exclude current years from the envelope
hist_env <- gdd %>%
  filter(!(year %in% c(2023, 2024))) %>%
  group_by(doy_date) %>%
  summarize(
    min_cum = min(cumulative_gdd, na.rm = TRUE),
    max_cum = max(cumulative_gdd, na.rm = TRUE)
  )

gdd_2023 <- filter(gdd, year == 2023)
gdd_2024 <- filter(gdd, year == 2024)

ggplot() +
  # Shaded region for historical envelope
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  # 2023 solid line
  geom_line(
    data = gdd_2023,
    aes(x = doy_date, y = cumulative_gdd),
    color = "#E41A1C", size = 1.2, linetype = "solid"
  ) +
  # 2024 dashed line
  geom_line(
    data = gdd_2024,
    aes(x = doy_date, y = cumulative_gdd),
    color = "#377EB8", size = 1.2, linetype = "dashed"
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    title = "Cumulative Rainfall: Historical Range vs. Recent Years",
    x = "Day of Year",
    y = "Cumulative Precipitation (mm)"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  # Custom legend via manual color/linetype mapping:
  scale_color_manual(
    name = "Year",
    values = c("2023" = "#E41A1C", "2024" = "#377EB8")
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c("2023" = "solid", "2024" = "dashed")
  )

gdd_highlight <- gdd %>%
  filter(year %in% c(2023, 2024)) %>%
  mutate(year = as.character(year))

ggplot() +
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  geom_line(
    data = gdd_highlight,
    aes(x = doy_date, y = cumulative_gdd, color = year, linetype = year),
    size = 1.2
  ) +
  scale_color_manual(
    name = "Year",
    values = c("2023" = "#E41A1C", "2024" = "#377EB8"),
    labels = c("2023", "2024")
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c("2023" = "solid", "2024" = "dashed"),
    labels = c("2023", "2024")
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    title = "Cumulative Rainfall: Historical Range vs. Recent Years",
    x = "Day of Year",
    y = "Cumulative Growing Degree Days (GDD)"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )

mean_cum <- gdd %>%
  filter(!(year %in% c(2023, 2024))) %>% # use only historical for mean
  group_by(doy_date) %>%
  summarize(cumulative_gdd = mean(cumulative_gdd, na.rm = TRUE)) %>%
  mutate(year = "Mean") %>%
  filter(doy_date != "2000-12-31")

gdd_highlight <- gdd %>%
  filter(year %in% c(2023, 2024)) %>%
  mutate(year = as.character(year)) %>%
  bind_rows(mean_cum)

gdd_plot_v2 <- ggplot() +
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  geom_line(
    data = gdd_highlight,
    aes(x = doy_date, y = cumulative_gdd, color = year, linetype = year),
    size = 1.2
  ) +
  scale_color_manual(
    name = "Year",
    values = c(
      "2023" = "#E41A1C",
      "2024" = "#377EB8",
      "Mean" = "black"
    ),
    labels = c(
      "2023" = "2023",
      "2024" = "2024",
      "Mean" = "Mean (Historical)"
    )
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c(
      "2023" = "solid",
      "2024" = "dashed",
      "Mean" = "dotdash"
    ),
    labels = c(
      "2023" = "2023",
      "2024" = "2024",
      "Mean" = "Mean (Historical)"
    )
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    x = "",  # Remove x-axis label since it aligns with bottom plots
    y = "Cumulative Growing Degree Days (GDD)"
  ) +
  theme_publication() +
  theme(
  # Remove x-axis ticks
    legend.position = "top"
  )

hist_env <- rain %>%
  filter(!(year %in% c(2023, 2024))) %>%
  group_by(doy_date) %>%
  summarize(
    min_cum = min(cumulative_precip, na.rm = TRUE),
    max_cum = max(cumulative_precip, na.rm = TRUE)
  )

rain_2023 <- filter(rain, year == 2023)
rain_2024 <- filter(rain, year == 2024)

ggplot() +
  # Shaded region for historical envelope
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  # 2023 solid line
  geom_line(
    data = rain_2023,
    aes(x = doy_date, y = cumulative_precip),
    color = "#E41A1C", size = 1.2, linetype = "solid"
  ) +
  # 2024 dashed line
  geom_line(
    data = rain_2024,
    aes(x = doy_date, y = cumulative_precip),
    color = "#377EB8", size = 1.2, linetype = "dashed"
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    title = "Cumulative Rainfall: Historical Range vs. Recent Years",
    x = "Day of Year",
    y = "Cumulative Precipitation (mm)"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  # Custom legend via manual color/linetype mapping:
  scale_color_manual(
    name = "Year",
    values = c("2023" = "#E41A1C", "2024" = "#377EB8")
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c("2023" = "solid", "2024" = "dashed")
  )

rain_highlight <- rain %>%
  filter(year %in% c(2023, 2024)) %>%
  mutate(year = as.character(year))

ggplot() +
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  geom_line(
    data = rain_highlight,
    aes(x = doy_date, y = cumulative_precip, color = year, linetype = year),
    size = 1.2
  ) +
  scale_color_manual(
    name = "Year",
    values = c("2023" = "#E41A1C", "2024" = "#377EB8"),
    labels = c("2023", "2024")
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c("2023" = "solid", "2024" = "dashed"),
    labels = c("2023", "2024")
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    title = "Cumulative Rainfall: Historical Range vs. Recent Years",
    x = "Day of Year",
    y = "Cumulative Precipitation (mm)"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )

mean_cum <- rain %>%
  filter(!(year %in% c(2023, 2024))) %>% # use only historical for mean
  group_by(doy_date) %>%
  summarize(cumulative_precip = mean(cumulative_precip, na.rm = TRUE)) %>%
  mutate(year = "Mean") %>%
  filter(doy_date != "2000-12-31")

rain_highlight <- rain %>%
  filter(year %in% c(2023, 2024)) %>%
  mutate(year = as.character(year)) %>%
  bind_rows(mean_cum)

rain_plot_v2 <- ggplot() +
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  geom_line(
    data = rain_highlight,
    aes(x = doy_date, y = cumulative_precip, color = year, linetype = year),
    size = 1.2
  ) +
  scale_color_manual(
    name = "Year",
    values = c(
      "2023" = "#E41A1C",
      "2024" = "#377EB8",
      "Mean" = "black"
    ),
    labels = c(
      "2023" = "2023",
      "2024" = "2024",
      "Mean" = "Mean (Historical)"
    )
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c(
      "2023" = "solid",
      "2024" = "dashed",
      "Mean" = "dotdash"
    ),
    labels = c(
      "2023" = "2023",
      "2024" = "2024",
      "Mean" = "Mean (Historical)"
    )
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    x = "",  # Remove x-axis label since it aligns with bottom plots
    y = "Cumulative Precipitation (mm)"
  ) +
  theme_publication() +
  theme(
     # Remove x-axis ticks
    legend.position = "top"
  )

rain_plot_v2
# Modify pdplot to have centered legend
pdplot <- rain_plot_v2 | gdd_plot_v2 

ggsave(
  "figures/gdd_plot_v2.png",
  pdplot,
  width = 8.5, height = 11, dpi = 350
)
pdplot
```

# Figure 1: Soil Moisture and Temperature (with per-date significance)

```{r}
#| label: fig-soil-moisture-temp
#| fig-cap: "Daily soil moisture and temperature over the study period (asterisks indicate p < 0.05 between treatments for that date)"
#| fig-width: 10
#| fig-height: 8

moist_temp <- flux_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  rename(Treatment = treatment) %>%
  group_by(Treatment, year, date) %>%
  summarise(
    mean_soil_moisture = mean(swc_2_mean, na.rm = TRUE),
    mean_soil_temp = mean(ts_2_mean, na.rm = TRUE),
    .groups = "drop"
  )
colnames(moist_temp)
# --- Per-date (year + date) t-tests between treatments on raw replicate data ---
raw_soil <- flux_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  rename(Treatment = treatment) %>%
  mutate(year = year(date))

colnames(raw_soil)

get_date_pvals <- function(df, value_col) {
  df %>%
    group_by(year, date) %>%
    summarise(
      p = {
        vals <- .data[[value_col]]
        trt  <- Treatment
        # Need exactly the two treatments and at least one non-NA in each
        has_two <- length(unique(na.omit(trt))) == 2
        counts  <- table(trt[!is.na(vals)])
        ok <- has_two && all(counts >= 1) && length(na.omit(vals)) >= 2
        if (ok) {
          out <- tryCatch(t.test(vals ~ trt)$p.value, error = function(e) NA_real_)
          out
        } else NA_real_
      },
      .groups = "drop"
    ) %>%
    filter(!is.na(p) & p < 0.05)
}

pvals_moist <- get_date_pvals(raw_soil, "swc_2_mean")
pvals_temp  <- get_date_pvals(raw_soil, "ts_2_mean")

# Split data by year
moist_temp_2023 <- filter(moist_temp, year == 2023)
moist_temp_2024 <- filter(moist_temp, year == 2024)

# Calculate global y-axis limits for consistent scaling within each row
global_moisture_limits <- range(moist_temp$mean_soil_moisture, na.rm = TRUE)
global_temp_limits <- range(moist_temp$mean_soil_temp, na.rm = TRUE)

# Add some padding for the star positioning
global_moisture_limits[2] <- global_moisture_limits[2] * 1.12  # 12% headroom for stars
global_temp_limits[2] <- global_temp_limits[2] * 1.12

# Calculate nice breaks for consistent tick marks
moisture_breaks <- pretty(global_moisture_limits, n = 5)
temp_breaks <- pretty(global_temp_limits, n = 5)

# Star positions - use per-date positioning but within global limits
moisture_stars <- moist_temp %>%
  group_by(year, date) %>%
  summarise(y_star = max(mean_soil_moisture, na.rm = TRUE) * 1.05, .groups = "drop") %>%
  inner_join(pvals_moist, by = c("year", "date")) %>%
  filter(is.finite(y_star))

moisture_segments <- moisture_stars %>%
  distinct(year, date) %>%
  left_join(moist_temp, by = c("year", "date")) %>%
  group_by(year, date) %>%
  slice_max(order_by = mean_soil_moisture, n = 1, with_ties = FALSE) %>%
  mutate(
    x = date - 0.5,
    xend = date + 0.5,
    y = 0.5
  ) %>%
  ungroup()

temp_stars <- moist_temp %>%
  group_by(year, date) %>%
  summarise(y_star = max(mean_soil_temp, na.rm = TRUE) * 1.05, .groups = "drop") %>%
  inner_join(pvals_temp, by = c("year", "date")) %>%
  filter(is.finite(y_star))

temp_segments <- temp_stars %>%
  distinct(year, date) %>%
  left_join(moist_temp, by = c("year", "date")) %>%
  group_by(year, date) %>%
  slice_max(order_by = mean_soil_temp, n = 1, with_ties = FALSE) %>%
  mutate(
    x = date - 0.5,
    xend = date + 0.5,
    y = 35 
  ) %>%
  ungroup()

# 2023 Soil Moisture (bottom left)
p1 <- ggplot(moist_temp_2023, aes(x = date, y = mean_soil_moisture, color = Treatment, shape = Treatment)) +
  geom_line(linewidth = .5) +
  geom_point(size = 1.5) +
  scale_color_treatments() +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + Rye" = 15)) +  # circle and square
  scale_x_date(date_breaks = "1 month", date_labels = "%b",
               limits = c(as.Date("2023-01-01"), as.Date("2023-12-31"))) +
  scale_y_continuous(limits = global_moisture_limits, breaks = moisture_breaks, expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    x = "2023",
    y = "Soil Moisture (m³/m³)"
  ) +
  geom_hline(yintercept = 0.5, color = "grey75", linewidth = 7) +
  geom_segment(
    data = moisture_segments %>% filter(year == 2023),
    aes(x = x, xend = xend, y = y, yend = y, color = Treatment),
    linewidth = 7,
    inherit.aes = FALSE, show.legend = FALSE
  ) +
  theme_publication() +
  theme(
    legend.position = "none"
  )
p1
# 2024 Soil Moisture (bottom right)
p2 <- ggplot(moist_temp_2024, aes(x = date, y = mean_soil_moisture, color = Treatment, shape = Treatment)) +
  geom_line(linewidth = .5) +
  geom_point(size = 1.5) +
  scale_color_treatments() +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + Rye" = 15)) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b",
               limits = c(as.Date("2024-01-01"), as.Date("2024-12-31"))) +
  scale_y_continuous(limits = global_moisture_limits, breaks = moisture_breaks, expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    x = "2024",
    y = ""
  ) +
  geom_hline(yintercept = 0.5, color = "grey75", linewidth = 7) +
  geom_segment(
    data = moisture_segments %>% filter(year == 2024),
    aes(x = x, xend = xend, y = y, yend = y, color = Treatment),
    linewidth = 7,
    inherit.aes = FALSE, show.legend = FALSE
  ) +
  theme_publication() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "none"
  )
p2
# 2023 Soil Temperature (top left)
p3 <- ggplot(moist_temp_2023, aes(x = date, y = mean_soil_temp, color = Treatment, shape = Treatment)) +
  geom_line(linewidth = .5) +
  geom_point(size = 1.5) +
  scale_color_treatments() +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + Rye" = 15)) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b",
               limits = c(as.Date("2023-01-01"), as.Date("2023-12-31"))) +
  scale_y_continuous(limits = global_temp_limits, breaks = temp_breaks, expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    x = "",
    y = "Soil Temperature (°C)"
  ) +
  geom_hline(yintercept = 35, color = "grey75", linewidth = 7) +
  geom_segment(
    data = temp_segments %>% filter(year == 2023),
    aes(x = x, xend = xend, y = y, yend = y, color = Treatment),
    linewidth = 7,
    inherit.aes = FALSE, show.legend = FALSE
  ) +
  theme_publication() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "none"
  )
p3

# 2024 Soil Temperature (top right)
p4 <- ggplot(moist_temp_2024, aes(x = date, y = mean_soil_temp, color = Treatment, shape = Treatment)) +
  geom_line(linewidth = .5) +
  geom_point(size = 1.5) +
  scale_color_treatments() +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + Rye" = 15)) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b",
               limits = c(as.Date("2024-01-01"), as.Date("2024-12-31"))) +
  scale_y_continuous(limits = global_temp_limits, breaks = temp_breaks, expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    x = "",
    y = ""
  ) +
  geom_hline(yintercept = 35, color = "grey75", linewidth = 7) +
  geom_segment(
    data = temp_segments %>% filter(year == 2024),
    aes(x = x, xend = xend, y = y, yend = y, color = Treatment),
    linewidth = 7,
    inherit.aes = FALSE, show.legend = FALSE
  ) +
  theme_publication() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "none"
  )

p4
# Arrange panels: temperature 2023/2024 on top, moisture 2023/2024 on bottom
soil_4panel <- (p3 | p4) / (p1 | p2) +
  patchwork::plot_layout(guides = "collect", heights = c(1, 1)) &
  theme(
    legend.position      = "top",
    legend.justification = "center",
    legend.direction     = "horizontal",
    legend.box           = "horizontal",   # keeps multiple guides in one row when possible
    legend.margin        = margin(b = 4)
  )
soil_4panel
ggsave("figures/figure2_soil_moisture_temperature.png", soil_4panel, width = 6.5, height = 8, dpi = 300, bg = "white")

six_panel_plot <-
  (pdplot) +
  patchwork::plot_layout(guides = "collect", heights = c(1, 1)) &
  theme(
    legend.position      = "top",
    legend.justification = "center",
    legend.direction     = "horizontal",
    legend.box           = "horizontal",   # keeps multiple guides in one row when possible
    legend.margin        = margin(b = 4)
  )

ggsave("figures/figure1_weather.png", six_panel_plot, width = 6.5, height = 8, dpi = 300, bg = "white")
six_panel_plot

```

```{r}

# Moisture difference by date (S+R - S), faceted by year
soil_moisture_diff <- moist_temp %>%
  select(year, date, Treatment, mean_soil_moisture) %>%
  pivot_wider(names_from = Treatment, values_from = mean_soil_moisture) %>%
  mutate(diff = `Sorghum + Rye` - Sorghum) %>%
  filter(!is.na(diff))

p_moist_diff <- ggplot(soil_moisture_diff, aes(x = date, y = diff)) +
  geom_col(fill = "#377EB8", alpha = 0.7, width = 1) +
  geom_hline(yintercept = 0, color = "black", linetype = "dashed") +
  labs(title = "Soil Moisture Difference (S+R - S)", x = "Date", y = "Δ Soil Moisture") +
  facet_wrap(~year, nrow = 2, scales = "free_x") +
  theme_publication() +
  theme(legend.position = "none")

ggsave("figures/soil_moisture_difference.png", p_moist_diff, width = 8, height = 6, dpi = 300)

# Temperature difference by date (S+R - S), faceted by year
soil_temp_diff <- moist_temp %>%
  select(year, date, Treatment, mean_soil_temp) %>%
  pivot_wider(names_from = Treatment, values_from = mean_soil_temp) %>%
  mutate(diff = `Sorghum + Rye` - Sorghum) %>%
  filter(!is.na(diff))

p_temp_diff <- ggplot(soil_temp_diff, aes(x = date, y = diff)) +
  geom_col(fill = "#e23737ff", alpha = 0.7, width = 1) +
  geom_hline(yintercept = 0, color = "black", linetype = "dashed") +
  labs(title = "Soil Temperature Difference (S+R - S)", x = "Date", y = "Δ Soil Temp (°C)") +
  facet_wrap(~year, nrow = 2, scales = "free_x") +
  theme_publication() +
  theme(legend.position = "none")

ggsave("figures/soil_temperature_difference.png", p_temp_diff, width = 8, height = 6, dpi = 300)
```

# Figure 2

```{r figure-n2o-flux}
#| label: fig-n2o-flux
#| fig-cap: "Daily N2O fluxes over the study period"
#| fig-width: 10
#| fig-height: 9

# Build daily treatment means and SE for N2O flux using existing flux_data
daily_flux <- flux_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(Treatment = treatment, year = lubridate::year(date)) %>%
  filter(year %in% c(2023, 2024)) %>%
  group_by(Treatment, year, date) %>%
  summarise(
    mean_flux = mean(gnha_day_no_negative, na.rm = TRUE) / 1000,  # Convert g to kg
    se_flux   = sd(gnha_day_no_negative, na.rm = TRUE) / sqrt(sum(!is.na(gnha_day_no_negative))) / 1000,  # Convert g to kg
    .groups = "drop"
  )

# Get flux measurement date ranges for each year
flux_date_ranges <- daily_flux %>%
  group_by(year) %>%
  summarise(
    min_date = min(date, na.rm = TRUE),
    max_date = max(date, na.rm = TRUE),
    .groups = "drop"
  )

# Calculate daily significance tests between treatments
daily_significance <- flux_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(year = lubridate::year(date)) %>%
  filter(year %in% c(2023, 2024)) %>%
  group_by(year, date) %>%
  summarise(
    p_value = {
      # Get flux values for each treatment
      sorghum_flux <- gnha_day_no_negative[treatment == "Sorghum"]
      sorghum_rye_flux <- gnha_day_no_negative[treatment == "Sorghum + Rye"]

      # Remove NA values
      sorghum_flux <- sorghum_flux[!is.na(sorghum_flux)]
      sorghum_rye_flux <- sorghum_rye_flux[!is.na(sorghum_rye_flux)]

      # Perform t-test if we have enough data
      if (length(sorghum_flux) >= 2 && length(sorghum_rye_flux) >= 2) {
        tryCatch({
          t_result <- t.test(sorghum_flux, sorghum_rye_flux)
          t_result$p.value
        }, error = function(e) NA_real_)
      } else {
        NA_real_
      }
    },
    .groups = "drop"
  ) %>%
  mutate(
    significant = p_value < 0.05,
    star_label = ifelse(significant & !is.na(p_value), "*", "")
  )

# Get max flux values for star positioning
max_flux_by_date <- daily_flux %>%
  group_by(year, date) %>%
  summarise(max_flux = max(mean_flux + se_flux, na.rm = TRUE), .groups = "drop")

# Combine significance data with position data
star_data <- daily_significance %>%
  left_join(max_flux_by_date, by = c("year", "date")) %>%
  filter(star_label == "*") %>%
  mutate(star_y = max_flux * 1.1)  # Position stars 10% above the highest error bar

# Filter precipitation to match flux measurement periods only
daily_precip_trimmed <- rain %>%
  transmute(date, year, precipmm) %>%
  filter(year %in% c(2023, 2024)) %>%
  left_join(flux_date_ranges, by = "year") %>%
  filter(date >= min_date, date <= max_date) %>%
  select(date, year, precipmm)

# Print the date ranges for verification
cat("Flux measurement ranges:\n")
print(flux_date_ranges)
cat("\nPrecipitation trimmed to match flux periods\n")

# Fertilizer event dates
fert_events <- tibble(
  year = c(2023, 2024),
  fertilizer_date = as.Date(c("2023-05-05", "2024-07-17"))
)

# 1) Precipitation plot (faceted, top row) - trimmed to flux dates
precip_plot <- ggplot(daily_precip_trimmed, aes(x = date, y = precipmm)) +
  geom_col(fill = "#000000ff", color = "black", width = 1) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  scale_y_reverse(name = "Daily Precipitation (mm)") +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(x = "")

# 2) Daily flux plot (faceted, middle row)
daily_flux_plot <- ggplot(daily_flux, aes(x = date, y = mean_flux, color = Treatment)) +
  geom_line(linewidth = 1.1, alpha = 0.85) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = mean_flux - se_flux, ymax = mean_flux + se_flux),
                width = 0.2, alpha = 0.5) +
  geom_vline(data = fert_events,
             aes(xintercept = as.numeric(fertilizer_date)),
             linetype = "dashed", color = "red", alpha = 0.7, inherit.aes = FALSE) +
  geom_text(data = star_data,
            aes(x = date, y = star_y, label = star_label),
            color = "black", size = 5, inherit.aes = FALSE) +
  scale_color_treatments() +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  labs(y = expression("Daily N"[2]*"O Flux (g N ha"^-1*" day"^-1*")"),
       color = "Treatment") +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.text = element_blank(),
    legend.position = "none"  # Hide strip text for middle row
  ) +
  labs(x = "")

# 3) Build cumulative flux data (both years combined for faceting)
cum_flux_combined <- daily_flux %>%
  arrange(Treatment, year, date) %>%
  group_by(Treatment, year) %>%
  # Use actual measurement date ranges instead of full calendar year
  left_join(flux_date_ranges, by = "year") %>%
  summarise(
    start_date = first(min_date),
    end_date = first(max_date),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(all_dates = list(seq.Date(start_date, end_date, by = "day"))) %>%
  unnest(all_dates) %>%
  rename(date = all_dates) %>%
  select(-start_date, -end_date) %>%
  # Join with observed data
  left_join(daily_flux, by = c("Treatment", "year", "date")) %>%
  mutate(has_sample = !is.na(mean_flux)) %>%
  group_by(Treatment, year) %>%
  # Interpolate within observed ranges only (rule = 1)
  mutate(
    mean_flux_interp = approx(
      x = date[!is.na(mean_flux)],
      y = mean_flux[!is.na(mean_flux)],
      xout = date, rule = 1, ties = "ordered"
    )$y,
    se_flux_interp = approx(
      x = date[!is.na(se_flux)],
      y = se_flux[!is.na(se_flux)],
      xout = date, rule = 1, ties = "ordered"
    )$y
  ) %>%
  # Filter to only include dates within measurement range
  filter(!is.na(mean_flux_interp)) %>%
  # Calculate cumulative
  mutate(
    cum_flux = cumsum(mean_flux_interp),
    cum_se = sqrt(cumsum(se_flux_interp^2))
  ) %>%
  ungroup()

# 4) Cumulative flux plot (faceted, bottom row with x-axis labels)
cumulative_flux_plot <- ggplot(cum_flux_combined, aes(x = date, y = cum_flux, color = Treatment, fill = Treatment)) +
  geom_ribbon(aes(ymin = pmax(cum_flux - cum_se, 0), ymax = cum_flux + cum_se),
              alpha = 0.2, linewidth = 0) +
  geom_line(linewidth = 1.1) +
  scale_color_treatments() +
  scale_fill_treatments() +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  labs(x = "Month", 
       y = expression("Cumulative N"[2]*"O Flux (g N ha"^-1*")"),
       color = "Treatment", fill = "Treatment") +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    strip.text = element_blank(),  # Hide strip text for bottom row
    legend.position = "bottom",
    legend.direction = "horizontal",
    strip.background = element_rect(fill = alpha("#A5CAD2", 0.2)),
    panel.spacing = unit(2, "lines")
  )

# Assemble final figure: 3 faceted rows
figure2 <- (precip_plot / daily_flux_plot / cumulative_flux_plot) +
  patchwork::plot_layout(heights = c(0.8, 1, 1.2))

figure2

ggsave("figures/figure2_daily_flux_precip_cumulative_2023_2024.png",
       figure2, width = 10, height = 9, dpi = 300, bg = "white")
```

Figure 2. Daily and cumulative N₂O fluxes and precipitation by year. Top panels: Daily N₂O flux and precipitation, trimmed to measurement windows. Middle panels: Daily N₂O flux with asterisks (\*) indicating dates where flux differs significantly between treatments (p \< 0.05). Bottom panels: Cumulative N₂O flux. Faceted by year. Colors indicate treatment. Axes are aligned for direct comparison.

## Figure 2 Alternative: Dual-Axis Version

```{r figure-2-dual-axis}
#| label: fig-n2o-flux-dual-axis
#| fig-cap: "Daily and cumulative N2O flux with precipitation on dual axes"
#| fig-width: 10
#| fig-height: 8

# Create dual-axis plots for each year
# Create dual-axis plots for each year
# First calculate global maxima for consistent y-axes
global_max_flux <- max(daily_flux$mean_flux + daily_flux$se_flux, na.rm = TRUE)
global_max_precip <- max(daily_precip_trimmed$precipmm, na.rm = TRUE)
global_max_cum_flux <- max(cum_flux_combined$cum_flux + cum_flux_combined$cum_se, na.rm = TRUE)

# Scale precipitation to fit on flux scale, positioned from top down
global_precip_scale_factor <- global_max_flux * 0.4 / global_max_precip
global_plot_top <- global_max_flux * 1.1

create_dual_axis_plot <- function(year_val, is_right_panel = FALSE) {
  # Filter data for the specific year
  flux_year <- daily_flux %>% filter(year == year_val)
  precip_year <- daily_precip_trimmed %>% filter(year == year_val)
  star_year <- star_data %>% filter(year == year_val)
  fert_year <- fert_events %>% filter(year == year_val)
  cum_flux_year <- cum_flux_combined %>% filter(year == year_val)
  cum_flux_points <- cum_flux_year %>% filter(has_sample)

    # Full-year limits (force Jan 1 → Dec 31 even if data are sparse)
  year_start <- as.Date(sprintf("%d-01-01", year_val))
  year_end   <- as.Date(sprintf("%d-12-31", year_val))

  # Daily flux plot with precipitation
  daily_plot <- ggplot() +
    # Precipitation bars (from top down, above the data)
    geom_rect(data = precip_year,
              aes(xmin = date - 0.5, xmax = date + 0.5,
                  ymin = global_plot_top - precipmm * global_precip_scale_factor, ymax = global_plot_top),
              fill = "#377EB8", alpha = 0.7) +

    # Daily flux lines and points
    #geom_line(data = flux_year,
     #         aes(x = date, y = mean_flux, color = Treatment),
      #        linewidth = 1.1, alpha = 0.85) +
    geom_point(data = flux_year,
               aes(x = date, y = mean_flux, color = Treatment),
               size = 2) +
    geom_errorbar(data = flux_year,
                  aes(x = date, ymin = mean_flux - se_flux, ymax = mean_flux + se_flux, color = Treatment),
                  width = 0.2, alpha = 0.5) +

    # Fertilizer events
    geom_vline(data = fert_year,
               aes(xintercept = as.numeric(fertilizer_date)),
               linetype = "dashed", color = "red", alpha = 0.7) +

    # Significance stars
    geom_text(data = star_year,
              aes(x = date, y = star_y, label = star_label),
              color = "black", size = 8) +

    # Scales and styling
    scale_color_treatments() +
    guides(color = "none") +
    scale_x_date(date_breaks = "1 month", date_labels = "%b",
                 limits = c(year_start, year_end)) +

    # Primary y-axis (flux), using global limits for consistency
    scale_y_continuous(
      name = if (!is_right_panel) expression("Daily N"[2]*"O Flux (kg N ha"^-1*" day"^-1*")") else "",
      limits = c(0, global_plot_top),
      sec.axis = sec_axis(~ (global_plot_top - .) / global_precip_scale_factor,
                          name = if (is_right_panel) "Daily Precipitation (mm)" else "")
    ) +

    # Theme and labels
    theme_publication() +
    theme(
      legend.position = "none",
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      # Remove y-axis elements for right panel
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text(),
      # Remove secondary y-axis elements for left panel
      axis.text.y.right = if (is_right_panel) element_text(color = "#377EB8") else element_blank(),
      axis.ticks.y.right = if (is_right_panel) element_line() else element_blank(),
      axis.title.y.right = if (is_right_panel) element_text(color = "#377EB8") else element_blank()
    ) +
    labs(
      title = paste("", year_val),
      x = ""
    ) +

    # Add horizontal line at y=0 for reference
    geom_hline(yintercept = 0, linetype = "solid", alpha = 0.3)

  # Cumulative flux plot (bottom panel with x-axis labels)
  cumulative_plot <- ggplot(cum_flux_year, aes(x = date, y = cum_flux, color = Treatment)) +
    geom_ribbon(aes(ymin = pmax(cum_flux - cum_se, 0), ymax = cum_flux + cum_se, fill = Treatment),
                alpha = 0.2, linewidth = 0) +
    geom_line(linewidth = 1.1) +
    geom_point(data = cum_flux_points, aes(x = date, y = cum_flux, color = Treatment), size = 1.8) +
    scale_color_treatments() +
    scale_fill_treatments() +
    scale_x_date(date_breaks = "1 month", date_labels = "%b",
                 limits = c(year_start, year_end)) +
    scale_y_continuous(
      name = if (!is_right_panel) expression("Cumulative N"[2]*"O Flux (kg N ha"^-1*")") else "",
      limits = c(0, global_max_cum_flux)
    ) +
    labs(x = "Month") +
    theme_publication() +
    theme(
      legend.position = "none",
      # Remove y-axis elements for right panel
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text()
    )

  # Combine daily and cumulative plots vertically
  combined_plot <- (daily_plot / cumulative_plot) +
    patchwork::plot_layout(heights = c(1.2, 1))

  return(combined_plot)
}

# Create plots for both years
plot_2023 <- create_dual_axis_plot(2023, is_right_panel = FALSE)
plot_2024 <- create_dual_axis_plot(2024, is_right_panel = TRUE)

# Combine plots side by side
figure2_dual_axis <- (plot_2023 | plot_2024) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom", 
        legend.justification = "center",
        legend.box.just = "center")

figure2_dual_axis

# Save the dual-axis version
ggsave("figures/figure2_dual_axis_flux_precip_cumulative_2023_2024v2.png",
       figure2_dual_axis, width = 6.5, height = 8, dpi = 300, bg = "white")
ggsave("figures/figure2_dual_axis_flux_precip_cumulative_2023_2024v2BIG.png",
       figure2_dual_axis, width = 13.3, height = 7.5, dpi = 300, bg = "white")
```

Figure 2 Alternative. Daily and cumulative N₂O flux with precipitation on dual axes by year. Top panels: Daily N₂O flux with precipitation bars "raining down" from the top (blue, right y-axis) and daily N₂O flux plotted along the bottom axis (colored lines, left y-axis). Asterisks (\*) indicate dates where flux differs significantly between treatments (p \< 0.05). Red dashed lines show fertilizer application dates. Bottom panels: Cumulative N₂O flux. X-axes are aligned between daily and cumulative panels for direct comparison.

# Figure 3: Nitrogen Leaching

```{r figure-leaching}
#| label: fig-leaching
#| fig-cap: "Tile-drain nitrogen loss and cumulative leaching"
#| fig-width: 10
#| fig-height: 9

# Build daily treatment means and SE for leaching (like Figure 2 does for flux)
# Ensure plot area is available in this chunk (avoid dependency on earlier cells)
plot_area_ft2 <- 120 * 160
plot_area_ha <- plot_area_ft2 / 107639.1041671

daily_leaching <- leaching_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(
    daily_n_loss_kgha = (total_n_loss_mg / 1e6) / plot_area_ha
  ) %>%
  group_by(plot, treatment, year, date) %>%
  summarise(
    daily_loss = mean(daily_n_loss_kgha, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(plot, treatment, year, date)

# Calculate treatment means and SE for daily losses
daily_leaching_summary <- daily_leaching %>%
  group_by(treatment, year, date) %>%
  summarise(
    mean_loss = mean(daily_loss, na.rm = TRUE),
    se_loss = sd(daily_loss, na.rm = TRUE) / sqrt(sum(!is.na(daily_loss))),
    .groups = "drop"
  )

# Get leaching measurement date ranges for each year (FROM the processed data like Figure 2)
leaching_date_ranges <- daily_leaching_summary %>%
  group_by(year) %>%
  summarise(
    min_date = min(date, na.rm = TRUE),
    max_date = max(date, na.rm = TRUE),
    .groups = "drop"
  )

print(leaching_date_ranges)

# Build cumulative leaching with robust handling for sparse observations
cum_leaching_combined <- daily_leaching_summary %>%
  arrange(treatment, year, date) %>%
  group_by(treatment, year) %>%
  group_modify(~{
    df <- .x
    if (nrow(df) == 0) return(tibble())
    # Date span limited to observed range
    start_date <- min(df$date, na.rm = TRUE)
    end_date   <- max(df$date, na.rm = TRUE)
    all_dates  <- tibble(date = seq.Date(start_date, end_date, by = "day"))
    df_full <- all_dates %>% left_join(df, by = "date")
    # Interpolate within range when >= 2 points, otherwise treat missing days as 0 (to avoid blank figure)
    n_pts <- sum(!is.na(df$mean_loss))
    if (n_pts >= 2) {
      mean_loss_interp <- approx(x = df$date[!is.na(df$mean_loss)], y = df$mean_loss[!is.na(df$mean_loss)],
                                 xout = df_full$date, rule = 1, ties = "ordered")$y
      se_loss_interp   <- approx(x = df$date[!is.na(df$se_loss)], y = df$se_loss[!is.na(df$se_loss)],
                                 xout = df_full$date, rule = 1, ties = "ordered")$y
      df_full <- df_full %>% mutate(
        mean_loss_interp = mean_loss_interp,
        se_loss_interp   = se_loss_interp
      )
    } else {
      df_full <- df_full %>% mutate(
        mean_loss_interp = replace_na(mean_loss, 0),
        se_loss_interp   = replace_na(se_loss, 0)
      )
    }
    df_full %>%
      mutate(
        cum_loss = cumsum(replace_na(mean_loss_interp, 0)),
        cum_se   = sqrt(cumsum(replace_na(se_loss_interp, 0)^2))
      )
  }) %>%
  ungroup()

min(cum_leaching_combined$date)
max(cum_leaching_combined$date)

# Prepare faceted monthly data (like Figure 2)
monthly_leaching_faceted <- daily_leaching_summary %>%
  mutate(month_year = floor_date(date, "month")) %>%
  group_by(treatment, year, month_year) %>%
  summarise(
    monthly_total = sum(mean_loss, na.rm = TRUE),
    monthly_se = sqrt(sum(se_loss^2, na.rm = TRUE)),
    .groups = "drop"
  )

min(monthly_leaching_faceted$month_year)
max(monthly_leaching_faceted$month_year)

# 1) Monthly leaching plot (top row) - faceted like Figure 2
monthly_plot <- ggplot(monthly_leaching_faceted, aes(x = month_year, y = monthly_total, fill = treatment)) +
  geom_col(position = position_dodge(width = 20), width = 15) +
  geom_errorbar(aes(ymin = pmax(monthly_total - monthly_se, 0), ymax = monthly_total + monthly_se),
                position = position_dodge(width = 20), width = 5) +
  scale_fill_treatments() +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  labs(y = expression("Monthly N Loss (kg N ha"^-1*")"), fill = "Treatment") +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "none"
  ) +
  labs(x = "")


# 2) Cumulative leaching plot (bottom row) - faceted like Figure 2
# Also compute observed cumulative points for visibility when sparse
obs_points <- daily_leaching_summary %>%
  group_by(treatment, year) %>%
  arrange(date) %>%
  mutate(cum_obs = cumsum(replace_na(mean_loss, 0))) %>%
  ungroup()

cumulative_leaching_plot <- ggplot(cum_leaching_combined, aes(x = date, y = cum_loss, color = treatment, fill = treatment)) +
  geom_ribbon(aes(ymin = pmax(cum_loss - cum_se, 0), ymax = cum_loss + cum_se),
              alpha = 0.2, linewidth = 0) +
  geom_line(linewidth = 1.1) +
  # Show observed points for visibility when data are sparse
  geom_point(data = obs_points, inherit.aes = FALSE,
             aes(x = date, y = cum_obs, color = treatment),
             alpha = 0.5, shape = 16, size = 1.2) +
  scale_color_treatments() +
  scale_fill_treatments() +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  labs(x = "Month", 
       y = expression("Cumulative N Loss (kg N ha"^-1*")"),
       color = "Treatment", fill = "Treatment") +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    strip.text = element_blank(),  # Hide strip text for bottom row
    legend.position = "bottom",
    legend.direction = "horizontal",
    strip.background = element_rect(fill = alpha("#A5CAD2", 0.2)),
    panel.spacing = unit(2, "lines")
  )
# Assemble final figure: 2 faceted rows like Figure 2
figure3 <- (monthly_plot / cumulative_leaching_plot) +
  patchwork::plot_layout(heights = c(1, 1.2))

figure3

ggsave("figures/figure3_leaching_four_panel.png", figure3, width = 6.5, height = 9, dpi = 300, bg = "white")
```

Figure 3. Monthly and cumulative nitrogen leaching by year. Top panels: Monthly leaching losses (kg N ha⁻¹) by treatment. Bottom panels: Cumulative leaching losses. Faceted by year. Axes are aligned for direct comparison. Letters indicate Tukey-adjusted significance groups; treatments sharing a letter are not significantly different ( 𝛼 = 0.05 α=0.05).

## Figure 3 Alternative: Dual-Axis Version

```{r figure-3-dual-axis}
#| label: fig-leaching-dual-axis
#| fig-cap: "Daily nitrogen leaching and precipitation on dual axes with cumulative leaching"
#| fig-width: 10
#| fig-height: 8

# Calculate daily significance tests for leaching between treatments
daily_leaching_significance <- leaching_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(
    year = lubridate::year(date),
    daily_n_loss_kgha = (total_n_loss_mg / 1e6) / plot_area_ha
  ) %>%
  filter(year %in% c(2023, 2024)) %>%
  group_by(year, date) %>%
  summarise(
    p_value = {
      # Get leaching values for each treatment
      sorghum_loss <- daily_n_loss_kgha[treatment == "Sorghum"]
      sorghum_rye_loss <- daily_n_loss_kgha[treatment == "Sorghum + Rye"]

      # Remove NA values
      sorghum_loss <- sorghum_loss[!is.na(sorghum_loss)]
      sorghum_rye_loss <- sorghum_rye_loss[!is.na(sorghum_rye_loss)]

      # Perform t-test if we have enough data
      if (length(sorghum_loss) >= 2 && length(sorghum_rye_loss) >= 2) {
        tryCatch({
          t_result <- t.test(sorghum_loss, sorghum_rye_loss)
          t_result$p.value
        }, error = function(e) NA_real_)
      } else {
        NA_real_
      }
    },
    .groups = "drop"
  ) %>%
  mutate(
    significant = p_value < 0.05,
    star_label = ifelse(significant & !is.na(p_value), "*", "")
  )

# Get max leaching values for star positioning
max_leaching_by_date <- daily_leaching_summary %>%
  group_by(year, date) %>%
  summarise(max_loss = max(mean_loss + se_loss, na.rm = TRUE), .groups = "drop")

# Combine significance data with position data for leaching
leaching_star_data <- daily_leaching_significance %>%
  left_join(max_leaching_by_date, by = c("year", "date")) %>%
  filter(star_label == "*") %>%
  mutate(star_y = max_loss * 1.1)  # Position stars 10% above the highest error bar

# CRITICAL FIX: Get actual measurement date ranges from RAW leaching data
# This finds the first and last dates where we actually have leaching measurements
actual_leaching_date_ranges <- leaching_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(year = lubridate::year(date)) %>%
  filter(year %in% c(2023, 2024), !is.na(total_n_loss_mg)) %>%
  group_by(year) %>%
  summarise(
    min_date = min(date, na.rm = TRUE),
    max_date = max(date, na.rm = TRUE),
    .groups = "drop"
  )

cat("Actual leaching measurement date ranges:\n")
print(actual_leaching_date_ranges)

# Filter precipitation to match ACTUAL leaching measurement periods
daily_precip_leaching <- rain %>%
  transmute(date, year, precipmm) %>%
  filter(year %in% c(2023, 2024)) %>%
  left_join(actual_leaching_date_ranges, by = "year") %>%
  filter(date >= min_date, date <= max_date) %>%
  select(date, year, precipmm)

# CRITICAL FIX: Subset cumulative data to match actual measurement date range
cum_leaching_trimmed <- cum_leaching_combined %>%
  left_join(actual_leaching_date_ranges, by = "year") %>%
  filter(date >= min_date, date <= max_date) %>%
  select(-min_date, -max_date)

# Also trim observed points to match
obs_points_trimmed <- obs_points %>%
  left_join(actual_leaching_date_ranges, by = "year") %>%
  filter(date >= min_date, date <= max_date) %>%
  select(-min_date, -max_date)

# Create dual-axis plots for each year (leaching version)
# First calculate global maxima for consistent y-axes
global_max_loss <- max(daily_leaching_summary$mean_loss + daily_leaching_summary$se_loss, na.rm = TRUE)
global_max_precip_leaching <- max(daily_precip_leaching$precipmm, na.rm = TRUE)

# Scale precipitation to fit on loss scale, positioned from top down
global_precip_scale_factor_leaching <- global_max_loss * 0.4 / global_max_precip_leaching
global_plot_top_leaching <- global_max_loss * 1.1

create_leaching_dual_axis_plot <- function(year_val, is_right_panel = FALSE) {
  # Filter data for the specific year
  leaching_year <- daily_leaching_summary %>% filter(year == year_val)
  precip_year <- daily_precip_leaching %>% filter(year == year_val)
  star_year <- leaching_star_data %>% filter(year == year_val)

  # Get date range for this year - use ACTUAL measurement range
  date_range <- actual_leaching_date_ranges %>% filter(year == year_val)
  year_start <- as.Date(sprintf("%d-01-01", year_val))
  year_end   <- as.Date(sprintf("%d-12-31", year_val))
  # Create the plot
  p <- ggplot() +
    # Precipitation bars (from top down, above the data)
    geom_rect(data = precip_year,
              aes(xmin = date - 0.5, xmax = date + 0.5,
                  ymin = global_plot_top_leaching - precipmm * global_precip_scale_factor_leaching, ymax = global_plot_top_leaching),
              fill = "#377EB8", alpha = 0.7) +

    # Daily leaching lines and points
   # geom_line(data = leaching_year,
   #           aes(x = date, y = mean_loss, color = treatment),
   #           linewidth = 1.1, alpha = 0.85) +
    geom_point(data = leaching_year,
               aes(x = date, y = mean_loss, color = treatment),
               size = 2) +
    geom_errorbar(data = leaching_year,
                  aes(x = date, ymin = mean_loss - se_loss, ymax = mean_loss + se_loss, color = treatment),
                  width = 0.2, alpha = 0.5) +

    # Significance stars
    geom_text(data = star_year,
              aes(x = date, y = star_y, label = star_label),
              color = "black", size = 8) +

    # Scales and styling
    scale_color_treatments() +
    guides(color = "none") +
    scale_x_date(date_breaks = "1 month", date_labels = "%b",
                 limits = c(year_start, year_end)) +

    # Primary y-axis (leaching), using global limits for consistency
    scale_y_continuous(
      name = if (!is_right_panel) expression("Daily N Loss (kg N ha"^-1*" day"^-1*")") else "",
      limits = c(0, global_plot_top_leaching),
      sec.axis = sec_axis(~ (global_plot_top_leaching - .) / global_precip_scale_factor_leaching,
                          name = if (is_right_panel) "Daily Precipitation (mm)" else "")
    ) +

    # Theme and labels
    theme_publication() +
    theme(
      legend.position = "none",
      # Remove x-axis elements for top panel (like Figure 2)
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      # Remove y-axis elements for right panel
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text(),
      # Remove secondary y-axis elements for left panel
      axis.text.y.right = if (is_right_panel) element_text(color = "#377EB8") else element_blank(),
      axis.ticks.y.right = if (is_right_panel) element_line() else element_blank(),
      axis.title.y.right = if (is_right_panel) element_text(color = "#377EB8") else element_blank()
    ) +
    labs(
      title = paste("", year_val),
      x = ""  # Remove x label for top panel
    ) +

    # Add horizontal line at y=0 for reference
    geom_hline(yintercept = 0, linetype = "solid", alpha = 0.3)

  return(p)
}

# Create daily leaching plots for both years
daily_plot_2023 <- create_leaching_dual_axis_plot(2023, is_right_panel = FALSE)
daily_plot_2024 <- create_leaching_dual_axis_plot(2024, is_right_panel = TRUE)

# Combine daily plots side by side
daily_leaching_dual_axis <- (daily_plot_2023 | daily_plot_2024) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom", 
        legend.justification = "center",
        legend.box.just = "center")

# CRITICAL FIX: Modify cumulative plot to use trimmed data and matching x-axis limits
cumulative_leaching_plot_clean <- ggplot(cum_leaching_combined, aes(x = date, y = cum_loss, color = treatment, fill = treatment)) +
  geom_ribbon(aes(ymin = pmax(cum_loss - cum_se, 0), ymax = cum_loss + cum_se),
              alpha = 0.2, linewidth = 0) +
  geom_line(linewidth = 1.1) +
  # Show observed points for visibility when data are sparse - use trimmed data
  geom_point(data = obs_points_trimmed, inherit.aes = FALSE,
             aes(x = date, y = cum_obs, color = treatment),
             alpha = 0.5, shape = 16, size = 1.2) +
  scale_color_treatments() +
  scale_fill_treatments() +
  # Use SAME x-axis settings as daily plots for perfect alignment
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  labs(x = "Month",
       y = expression("Cumulative N Loss (kg N ha"^-1*")")) +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    strip.text = element_blank(),  # Hide strip text for consistency with Figure 2
    legend.position = "none",  # Hide legend since it's collected above
    strip.background = element_rect(fill = alpha("#A5CAD2", 0.2)),
    panel.spacing = unit(2, "lines")
  )

# Assemble final figure: daily dual-axis on top, cumulative below (like Figure 2)
figure3_dual_axis <- (daily_leaching_dual_axis / cumulative_leaching_plot_clean) +
  patchwork::plot_layout(heights = c(1.2, 1))

figure3_dual_axis

# Save the dual-axis version
ggsave("figures/figure3_dual_axis_leaching_precip_2023_2024.png",
       figure3_dual_axis, width = 6.5, height = 8, dpi = 300, bg = "white")
```

Figure 3 Alternative. Daily nitrogen leaching and precipitation on dual axes with cumulative leaching by year. Top panels: Daily nitrogen leaching with precipitation bars "raining down" from the top (light blue, right y-axis) and daily nitrogen loss plotted along the bottom axis (colored lines, left y-axis). Asterisks (\*) indicate dates where leaching differs significantly between treatments (p \< 0.05). Bottom panels: Cumulative nitrogen leaching. Faceted by year with consistent styling to Figure 2.

```{r}
# --- global limits and scaling (same as before) ---
global_max_loss <- max(daily_leaching_summary$mean_loss + daily_leaching_summary$se_loss, na.rm = TRUE)
global_max_precip_leaching <- max(daily_precip_leaching$precipmm, na.rm = TRUE)
global_max_cum_loss <- max(cum_leaching_trimmed$cum_loss + cum_leaching_trimmed$cum_se, na.rm = TRUE)

global_precip_scale_factor_leaching <- global_max_loss * 0.4 / global_max_precip_leaching
global_plot_top_leaching <- global_max_loss * 1.1

# --- updated dual-axis function (matches Figure 2 structure) ---
create_leaching_dual_axis_plot <- function(year_val, is_right_panel = FALSE) {
  leaching_year <- daily_leaching_summary %>% filter(year == year_val)
  precip_year   <- daily_precip_leaching  %>% filter(year == year_val)
  star_year     <- leaching_star_data     %>% filter(year == year_val)
  cum_year      <- cum_leaching_trimmed   %>% filter(year == year_val)
  obs_year      <- obs_points_trimmed     %>% filter(year == year_val)

  # full-year axis limits (Jan 1–Dec 31)
  year_start <- as.Date(sprintf("%d-01-01", year_val))
  year_end   <- as.Date(sprintf("%d-12-31", year_val))

  # ---- DAILY PANEL ----
  daily_plot <- ggplot() +
    geom_rect(
      data = precip_year,
      aes(xmin = date - 0.5, xmax = date + 0.5,
          ymin = global_plot_top_leaching - precipmm * global_precip_scale_factor_leaching,
          ymax = global_plot_top_leaching),
      fill = "#377EB8", alpha = 0.7
    ) +
    geom_point(
      data = leaching_year,
      aes(x = date, y = mean_loss, color = treatment),
      size = 2
    ) +
    geom_errorbar(
      data = leaching_year,
      aes(x = date, ymin = mean_loss - se_loss, ymax = mean_loss + se_loss, color = treatment),
      width = 0.2, alpha = 0.5
    ) +
    geom_text(
      data = star_year,
      aes(x = date, y = star_y, label = star_label),
      color = "black", size = 8
    ) +
    scale_color_treatments() +
    guides(color = "none") +
    scale_x_date(date_breaks = "1 month", date_labels = "%b",
                 limits = c(year_start, year_end)) +
    scale_y_continuous(
      name = if (!is_right_panel) expression("Daily N Loss (kg N ha"^-1*" day"^-1*")") else "",
      limits = c(0, global_plot_top_leaching),
      sec.axis = sec_axis(~ (global_plot_top_leaching - .) / global_precip_scale_factor_leaching,
                          name = if (is_right_panel) "Daily Precipitation (mm)" else "")
    ) +
    theme_publication() +
    theme(
      legend.position = "none",
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text(),
      axis.text.y.right = if (is_right_panel) element_text(color = "#377EB8") else element_blank(),
      axis.ticks.y.right = if (is_right_panel) element_line() else element_blank(),
      axis.title.y.right = if (is_right_panel) element_text(color = "#377EB8") else element_blank()
    ) +
    labs(title = paste("", year_val), x = "") +
    geom_hline(yintercept = 0, linetype = "solid", alpha = 0.3)

  # ---- CUMULATIVE PANEL (now identical to Figure 2) ----
  cumulative_plot <- ggplot(cum_year, aes(x = date, y = cum_loss, color = treatment)) +
    geom_ribbon(
      aes(ymin = pmax(cum_loss - cum_se, 0), ymax = cum_loss + cum_se, fill = treatment),
      alpha = 0.2, linewidth = 0
    ) +
    geom_line(linewidth = 1.1) +
    geom_point(
      data = obs_year,
      aes(x = date, y = cum_obs, color = treatment),
      size = 1.8
    ) +
    scale_color_treatments() +
    scale_fill_treatments() +
    scale_x_date(
      date_breaks = "1 month", date_labels = "%b",
      limits = c(year_start, year_end)
    ) +
    scale_y_continuous(
      name = if (!is_right_panel) expression("Cumulative N Loss (kg N ha"^-1*")") else "",
      limits = c(0, global_max_cum_loss)
    ) +
    labs(x = "Month") +
    theme_publication() +
    theme(
      legend.position = "none",
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text()
    )

  # ---- Combine top + bottom panels ----
  (daily_plot / cumulative_plot) +
    patchwork::plot_layout(heights = c(1.2, 1))
}

# --- Build panels and assemble full figure ---
leach_2023 <- create_leaching_dual_axis_plot(2023, is_right_panel = FALSE)
leach_2024 <- create_leaching_dual_axis_plot(2024, is_right_panel = TRUE)

figure3_dual_axis <- (leach_2023 | leach_2024) +
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position = "bottom",
        legend.justification = "center",
        legend.box.just = "center")

figure3_dual_axis
ggsave("figures/figure3_dual_axis_leaching_precip_2023_2024v2.png",
       figure3_dual_axis, width = 6.5, height = 8, dpi = 300, bg = "white")
ggsave("figures/figure3_dual_axis_leaching_precip_2023_2024v2BIG.png",
       figure3_dual_axis, width = 13.3, height = 7.5, dpi = 300, bg = "white")
```

# Figure 4: Annual Nitrogen Losses

```{r figure-annual-loss}
#| label: fig-annual-loss
#| fig-width: 10
#| fig-height: 6

# Summaries for annual leaching and N2O (reuse Table 3 summaries for consistency)
leach_summary_fig4 <- leaching_summary %>%
  transmute(treatment, year, mean_leach = mean_leaching,
            se_leach = sd_leaching / sqrt(n_plots))

n2o_summary_fig4 <- n2o_summary %>%
  transmute(treatment, year, mean_n2o,
            se_n2o = sd_n2o / sqrt(n_plots))

# Compute per-year Tukey letters for leaching (reuse helper used in Table 3)
leach_letters_fig4 <- annual_leaching %>%
  group_by(year) %>%
  group_modify(~ compute_letters_by_year(.x, "annual_cumulative_leaching")) %>%
  ungroup()

# Combine summaries
combined_loss <- full_join(leach_summary_fig4, n2o_summary_fig4, by = c("treatment", "year"))

loss_long <- combined_loss %>%
  pivot_longer(cols = c(mean_leach, mean_n2o), names_to = "component", values_to = "value") %>%
  mutate(
    se = if_else(component == "mean_leach", se_leach, se_n2o),
    component = recode(component, mean_leach = "Leached N", mean_n2o = "Nitrous Oxide"),
    treatment = factor(treatment, levels = c("Corn", "Soy", "Sorghum", "Sorghum + Rye"))
  )

loss_colors <- c("Leached N" = "#0A2E57FF", "Nitrous Oxide" = "#d11c16ff")

# Top-of-bar positions for letter placement
max_total <- loss_long %>%
  group_by(year, treatment) %>%
  summarise(total = sum(value, na.rm = TRUE), .groups = "drop_last") %>%
  summarise(max_total = max(total, na.rm = TRUE), .groups = "drop") %>%
  pull(max_total)

letters_pos <- combined_loss %>%
  mutate(total = coalesce(mean_leach, 0) + coalesce(mean_n2o, 0)) %>%
  left_join(leach_letters_fig4, by = c("treatment", "year")) %>%
  mutate(y = total + 0.03 * max_total) %>%
  select(year, treatment, letter, y)

figure4 <- ggplot(loss_long, aes(x = treatment, y = value, fill = component)) +
  geom_col(width = 0.7) +
  # add leaching letters above stacked bars (per year)
  geom_text(data = letters_pos, aes(x = treatment, y = y, label = letter),
            inherit.aes = FALSE, size = 5) +
  facet_wrap(~year, nrow = 1) +
  scale_fill_manual(values = loss_colors, name = "Loss Type") +
 # scale_y_continuous(limits = c(0, max_total * 1.08), expand = expansion(mult = c(0, 0.05))) +
  labs(x = "Treatment", y = expression("Annual N loss (kg N ha"^{-1}*")")) +
  theme_publication() +
  theme(legend.position = "top")

figure4

ggsave("figures/figure4_stacked_n_loss.png", figure4, width = 8.5, height = 6, dpi = 300, bg = "white")
```

Figure 4. Stacked annual nitrogen losses by treatment. Bars show mean annual N₂O and leaching losses (kg N ha⁻¹) by treatment and year. Letters indicate Tukey-adjusted significance groups; treatments sharing a letter are not significantly different ( 𝛼 = 0.05 α=0.05). \## Statistical summaries for annual losses

```{r}
annual_leaching %>% count(year, treatment)
plot_cumulative_n2o %>% count(year, treatment)

annual_leaching %>%
  group_by(year, treatment) %>%
  summarise(n = n(), n_non_na = sum(!is.na(annual_cumulative_leaching)), .groups = "drop")

plot_cumulative_n2o %>%
  group_by(year, treatment) %>%
  summarise(n = n(), n_non_na = sum(!is.na(annual_cumulative_n2o)), .groups = "drop")

letters_leach
letters_n2o
letters_leach %>% filter(treatment == "Corn")
letters_n2o   %>% filter(treatment == "Corn")

annual_leaching %>%
  group_by(year, treatment) %>%
  summarise(mean = mean(annual_cumulative_leaching), sd = sd(annual_cumulative_leaching),
            se = sd / sqrt(n()), .groups = "drop")

plot_cumulative_n2o %>%
  group_by(year, treatment) %>%
  summarise(mean = mean(annual_cumulative_n2o), sd = sd(annual_cumulative_n2o),
            se = sd / sqrt(n()), .groups = "drop")

# Leaching
split(annual_leaching, annual_leaching$year) |>
  lapply(\(d) pairwise.t.test(d$annual_cumulative_leaching, d$treatment, p.adjust.method = "none"))

# N2O
split(plot_cumulative_n2o, plot_cumulative_n2o$year) |>
  lapply(\(d) pairwise.t.test(d$annual_cumulative_n2o, d$treatment, p.adjust.method = "none"))
```

# Biomass and grain yeild

```{r biomass-yield}
#| label: biomass-yield
#| fig-cap: "Sorghum crop biomass and soy and corn grain yield"  



```

We are waiting on C:N data from the lab to complete this section.

# Summary

This document provides clean, efficient analysis following tidyverse principles:

-   **Consistent data processing** using `group_by()` and `summarise()`
-   **Functional programming** with custom helper functions
-   **Clear separation** between data processing and visualization
-   **Reproducible workflow** with proper chunk organization
-   **Professional styling** consistent across all outputs

Each table and figure is generated in its own chunk for modularity and clarity.