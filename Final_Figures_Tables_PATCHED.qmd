---
title: "Sorghum and Rye Project: Final Figures and Tables"
format: 
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    code-overflow: wrap
    fig-width: 10
    fig-height: 6
    embed-resources: true
    theme: default
execute:
  echo: true
  warning: false
  message: false
  error: false
  cache: false
---

# Setup and Data Loading

```{r table-3, message=FALSE, warning=FALSE}
#| label: tbl-nitrogen-losses
#| tbl-cap: "Annual nitrogen loss components and totals (rounded to 3 significant figures)."

library(dplyr)
library(gt)

# Expect combined_nitrogen_data with at least:
#   year, year_order, treatment, N2O_total_gNha, Leach_total_gNha, Total_reported_gNha
sf <- 3
fmt_sig <- function(x, sig = sf) signif(x, sig)

table3_inputs <- combined_nitrogen_data %>%
  mutate(
    N2O_total_gNha   = as.numeric(N2O_total_gNha),
    Leach_total_gNha = as.numeric(Leach_total_gNha),
    Sum_components   = rowSums(across(c(N2O_total_gNha, Leach_total_gNha)), na.rm = TRUE)
  ) %>%
  arrange(year_order, treatment) %>%
  mutate(
    across(c(N2O_total_gNha, Leach_total_gNha, Sum_components, Total_reported_gNha),
           ~ fmt_sig(.x, sf))
  )

table3_gt <- table3_inputs %>%
  gt(groupname_col = "year") %>%
  cols_label(
    treatment = "Treatment",
    N2O_total_gNha = html("N<sub>2</sub>O (g N ha<sup>−1</sup>)"),
    Leach_total_gNha = html("Leached NO<sub>3</sub> (g N ha<sup>−1</sup>)"),
    Sum_components = "Sum (check)",
    Total_reported_gNha = "Reported total"
  ) %>%
  tab_spanner(label = "Components (g N ha−1)", columns = c(N2O_total_gNha, Leach_total_gNha)) %>%
  fmt_number(columns = c(N2O_total_gNha, Leach_total_gNha, Sum_components, Total_reported_gNha),
             decimals = NA, drop_trailing_zeros = TRUE) %>%
  tab_source_note("All values rounded to 3 significant figures. 'Sum (check)' is the arithmetic sum of listed components.")

gtsave(table3_gt, "tables/table3_components_clean.rtf")
table3_gt
```

# Figure: test: Flow and Nitrogen Leaching Relationship

This will give a good idea of the variation between flow and nitrogen leaching across treatments and years.

```{r debug-leaching-data}
#| label: debug-leaching
#| echo: true

# Let's examine the leaching data structure to understand the issue
cat("=== LEACHING DATA STRUCTURE ===\n")
cat("Total rows in leaching_data:", nrow(leaching_data), "\n")
cat("Years present:", paste(sort(unique(leaching_data$year)), collapse = ", "), "\n")
cat("Treatments present:", paste(sort(unique(leaching_data$treatment)), collapse = ", "), "\n")
cat("Plots present:", paste(sort(unique(leaching_data$plot)), collapse = ", "), "\n\n")

# Check treatment-year combinations
cat("=== TREATMENT-YEAR COMBINATIONS ===\n")
treatment_year_summary <- leaching_data %>%
  group_by(year, treatment) %>%
  summarise(
    n_observations = n(),
    unique_plots = length(unique(plot)),
    plots = paste(sort(unique(plot)), collapse = ", "),
    .groups = "drop"
  ) %>%
  arrange(year, treatment)

print(treatment_year_summary)

# Check for potential data issues
cat("\n=== POTENTIAL ISSUES ===\n")
duplicate_check <- leaching_data %>%
  group_by(plot, treatment, year, date) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1)

if(nrow(duplicate_check) > 0) {
  cat("WARNING: Duplicate plot-treatment-year-date combinations found!\n")
  print(head(duplicate_check))
} else {
  cat("No duplicate plot-treatment-year-date combinations found.\n")
}

# Check if same plot appears in multiple treatments within same year
plot_treatment_check <- leaching_data %>%
  distinct(plot, treatment, year) %>%
  group_by(plot, year) %>%
  summarise(treatments = paste(sort(treatment), collapse = ", "), n_treatments = n(), .groups = "drop") %>%
  filter(n_treatments > 1)

if(nrow(plot_treatment_check) > 0) {
  cat("\nWARNING: Plots appear in multiple treatments within same year:\n")
  print(plot_treatment_check)
} else {
  cat("\nGood: Each plot has only one treatment per year.\n")
}
```

```{r figure-test}
#| label: fig-flow-leaching
#| fig-cap: "Annual tile drain flow and cumulative nitrogen losses by treatment"
#| fig-width: 10
#| fig-height: 6

# Calculate annual totals from leaching data - INDIVIDUAL PLOTS
plot_flow_n_data <- leaching_data %>%
  group_by(plot, treatment, year) %>%
  summarise(
    total_flow_L = sum(flow_l, na.rm = TRUE),  # Sum daily flow to get annual total
    total_n_loss_mg = max(cumulative_n_loss_mg, na.rm = TRUE),  # Use existing cumulative N
    .groups = "drop"
  ) %>%
  # Remove any infinite or negative values
  filter(is.finite(total_flow_L), is.finite(total_n_loss_mg), 
         total_flow_L >= 0, total_n_loss_mg >= 0) %>%
  # Create plot labels and grouping variables  
  mutate(
    plot_label = paste("Plot", plot),
    year_treatment = paste(year, treatment, sep = " "),
    treatment_year = paste(treatment, year, sep = "_"),
    # Create unique plot identifier within treatment-year
    plot_id = paste(plot, treatment, year, sep = "_")
  ) %>%
  # Arrange by treatment and year for better visual grouping
  arrange(year, treatment, plot)

# Check the data structure - should match expected sample sizes
cat("Plots per treatment-year combination:\n")
print(plot_flow_n_data %>% 
  group_by(year, treatment) %>% 
  summarise(n_plots = n(), plots = paste(sort(unique(plot)), collapse = ", "), .groups = "drop"))

# Create individual plot bars showing variation within treatments
flow_n_plot <- ggplot(plot_flow_n_data, aes(x = year_treatment, group = plot)) +
  # Flow bars for individual plots - side by side
  geom_col(aes(y = total_flow_L, fill = treatment), 
           position = position_dodge(width = 0.8), alpha = 0.8, width = 0.15) +
  # Nitrogen points (scaled to flow axis) for individual plots
  geom_point(aes(y = total_n_loss_mg * max(total_flow_L, na.rm = TRUE) / max(total_n_loss_mg, na.rm = TRUE), 
                 color = treatment), 
             position = position_dodge(width = 0.8), size = 4, shape = 18) +
  # Scales and formatting
  scale_fill_treatments() +
  scale_color_treatments() +
  scale_y_continuous(
    name = "Annual Tile Drain Flow (L)",
    labels = scales::comma,
    sec.axis = sec_axis(
      trans = ~ . * max(plot_flow_n_data$total_n_loss_mg, na.rm = TRUE) / max(plot_flow_n_data$total_flow_L, na.rm = TRUE),
      name = "Cumulative N Loss (mg)",
      labels = scales::comma
    )
  ) +
  labs(
    x = "Year and Treatment",
    fill = "Treatment",
    color = "Treatment"
  ) +
  theme_publication() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    legend.position = "bottom",
    plot.title = element_text(size = 14),
    plot.subtitle = element_text(size = 11, color = "gray40"),
    axis.title.y.right = element_text(angle = 90, vjust = 0.5),
    panel.grid.major.x = element_blank()
  ) +
  # Add subtle separators between treatment groups
  facet_grid(. ~ year, scales = "free_x", space = "free_x", 
             labeller = labeller(year = function(x) paste("Year", x)))

flow_n_plot

ggsave("figures/figuresupp1_flow_nitrogen_relationship.png", width = 10, height = 6, dpi = 300)
```

# Figure 1: Precipitation and Temperature

```{r figure-weather}
#| label: fig-weather
#| fig-cap: "Daily precipitation, temperature, and soil moisture over the study period"
#| fig-width: 10
#| fig-height: 6

# Exclude current years from the envelope
hist_env <- gdd %>%
  filter(!(year %in% c(2023, 2024))) %>%
  group_by(doy_date) %>%
  summarize(
    min_cum = min(cumulative_gdd, na.rm = TRUE),
    max_cum = max(cumulative_gdd, na.rm = TRUE)
  )

gdd_2023 <- filter(gdd, year == 2023)
gdd_2024 <- filter(gdd, year == 2024)

ggplot() +
  # Shaded region for historical envelope
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  # 2023 solid line
  geom_line(
    data = gdd_2023,
    aes(x = doy_date, y = cumulative_gdd),
    color = "#E41A1C", size = 1.2, linetype = "solid"
  ) +
  # 2024 dashed line
  geom_line(
    data = gdd_2024,
    aes(x = doy_date, y = cumulative_gdd),
    color = "#377EB8", size = 1.2, linetype = "dashed"
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    title = "Cumulative Rainfall: Historical Range vs. Recent Years",
    x = "Day of Year",
    y = "Cumulative Precipitation (mm)"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  # Custom legend via manual color/linetype mapping:
  scale_color_manual(
    name = "Year",
    values = c("2023" = "#E41A1C", "2024" = "#377EB8")
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c("2023" = "solid", "2024" = "dashed")
  )

gdd_highlight <- gdd %>%
  filter(year %in% c(2023, 2024)) %>%
  mutate(year = as.character(year))

ggplot() +
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  geom_line(
    data = gdd_highlight,
    aes(x = doy_date, y = cumulative_gdd, color = year, linetype = year),
    size = 1.2
  ) +
  scale_color_manual(
    name = "Year",
    values = c("2023" = "#E41A1C", "2024" = "#377EB8"),
    labels = c("2023", "2024")
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c("2023" = "solid", "2024" = "dashed"),
    labels = c("2023", "2024")
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    title = "Cumulative Rainfall: Historical Range vs. Recent Years",
    x = "Day of Year",
    y = "Cumulative Growing Degree Days (GDD)"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )

mean_cum <- gdd %>%
  filter(!(year %in% c(2023, 2024))) %>% # use only historical for mean
  group_by(doy_date) %>%
  summarize(cumulative_gdd = mean(cumulative_gdd, na.rm = TRUE)) %>%
  mutate(year = "Mean") %>%
  filter(doy_date != "2000-12-31")

gdd_highlight <- gdd %>%
  filter(year %in% c(2023, 2024)) %>%
  mutate(year = as.character(year)) %>%
  bind_rows(mean_cum)

gdd_plot_v2 <- ggplot() +
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  geom_line(
    data = gdd_highlight,
    aes(x = doy_date, y = cumulative_gdd, color = year, linetype = year),
    size = 1.2
  ) +
  scale_color_manual(
    name = "Year",
    values = c(
      "2023" = "#E41A1C",
      "2024" = "#377EB8",
      "Mean" = "black"
    ),
    labels = c(
      "2023" = "2023",
      "2024" = "2024",
      "Mean" = "Mean (Historical)"
    )
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c(
      "2023" = "solid",
      "2024" = "dashed",
      "Mean" = "dotdash"
    ),
    labels = c(
      "2023" = "2023",
      "2024" = "2024",
      "Mean" = "Mean (Historical)"
    )
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    x = "",  # Remove x-axis label since it aligns with bottom plots
    y = "Cumulative Growing Degree Days (GDD)"
  ) +
  theme_publication() +
  theme(
  # Remove x-axis ticks
    legend.position = "top"
  )

hist_env <- rain %>%
  filter(!(year %in% c(2023, 2024))) %>%
  group_by(doy_date) %>%
  summarize(
    min_cum = min(cumulative_precip, na.rm = TRUE),
    max_cum = max(cumulative_precip, na.rm = TRUE)
  )

rain_2023 <- filter(rain, year == 2023)
rain_2024 <- filter(rain, year == 2024)

ggplot() +
  # Shaded region for historical envelope
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  # 2023 solid line
  geom_line(
    data = rain_2023,
    aes(x = doy_date, y = cumulative_precip),
    color = "#E41A1C", size = 1.2, linetype = "solid"
  ) +
  # 2024 dashed line
  geom_line(
    data = rain_2024,
    aes(x = doy_date, y = cumulative_precip),
    color = "#377EB8", size = 1.2, linetype = "dashed"
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    title = "Cumulative Rainfall: Historical Range vs. Recent Years",
    x = "Day of Year",
    y = "Cumulative Precipitation (mm)"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  # Custom legend via manual color/linetype mapping:
  scale_color_manual(
    name = "Year",
    values = c("2023" = "#E41A1C", "2024" = "#377EB8")
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c("2023" = "solid", "2024" = "dashed")
  )

rain_highlight <- rain %>%
  filter(year %in% c(2023, 2024)) %>%
  mutate(year = as.character(year))

ggplot() +
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  geom_line(
    data = rain_highlight,
    aes(x = doy_date, y = cumulative_precip, color = year, linetype = year),
    size = 1.2
  ) +
  scale_color_manual(
    name = "Year",
    values = c("2023" = "#E41A1C", "2024" = "#377EB8"),
    labels = c("2023", "2024")
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c("2023" = "solid", "2024" = "dashed"),
    labels = c("2023", "2024")
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    title = "Cumulative Rainfall: Historical Range vs. Recent Years",
    x = "Day of Year",
    y = "Cumulative Precipitation (mm)"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )

mean_cum <- rain %>%
  filter(!(year %in% c(2023, 2024))) %>% # use only historical for mean
  group_by(doy_date) %>%
  summarize(cumulative_precip = mean(cumulative_precip, na.rm = TRUE)) %>%
  mutate(year = "Mean") %>%
  filter(doy_date != "2000-12-31")

rain_highlight <- rain %>%
  filter(year %in% c(2023, 2024)) %>%
  mutate(year = as.character(year)) %>%
  bind_rows(mean_cum)

rain_plot_v2 <- ggplot() +
  geom_ribbon(
    data = hist_env,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  geom_line(
    data = rain_highlight,
    aes(x = doy_date, y = cumulative_precip, color = year, linetype = year),
    size = 1.2
  ) +
  scale_color_manual(
    name = "Year",
    values = c(
      "2023" = "#E41A1C",
      "2024" = "#377EB8",
      "Mean" = "black"
    ),
    labels = c(
      "2023" = "2023",
      "2024" = "2024",
      "Mean" = "Mean (Historical)"
    )
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c(
      "2023" = "solid",
      "2024" = "dashed",
      "Mean" = "dotdash"
    ),
    labels = c(
      "2023" = "2023",
      "2024" = "2024",
      "Mean" = "Mean (Historical)"
    )
  ) +
  scale_x_date(
    date_breaks = "1 month", # Breaks at each month
    date_labels = "%b" # Label as abbreviated month names
  ) +
  labs(
    x = "",  # Remove x-axis label since it aligns with bottom plots
    y = "Cumulative Precipitation (mm)"
  ) +
  theme_publication() +
  theme(
     # Remove x-axis ticks
    legend.position = "top"
  )

rain_plot_v2
# Modify pdplot to have centered legend
pdplot <- rain_plot_v2 | gdd_plot_v2 

ggsave(
  "figures/gdd_plot_v2.png",
  pdplot,
  width = 8.5, height = 11, dpi = 350
)
pdplot
```

# Figure 1: Soil Moisture and Temperature (with per-date significance)

```{r}
#| label: fig-soil-moisture-temp
#| fig-cap: "Daily soil moisture and temperature over the study period (asterisks indicate p < 0.05 between treatments for that date)"
#| fig-width: 10
#| fig-height: 8

moist_temp <- flux_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  rename(Treatment = treatment) %>%
  group_by(Treatment, year, date) %>%
  summarise(
    mean_soil_moisture = mean(swc_2_mean, na.rm = TRUE),
    mean_soil_temp = mean(ts_2_mean, na.rm = TRUE),
    .groups = "drop"
  )
colnames(moist_temp)
# --- Per-date (year + date) t-tests between treatments on raw replicate data ---
raw_soil <- flux_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  rename(Treatment = treatment) %>%
  mutate(year = year(date))

colnames(raw_soil)

get_date_pvals <- function(df, value_col) {
  df %>%
    group_by(year, date) %>%
    summarise(
      p = {
        vals <- .data[[value_col]]
        trt  <- Treatment
        # Need exactly the two treatments and at least one non-NA in each
        has_two <- length(unique(na.omit(trt))) == 2
        counts  <- table(trt[!is.na(vals)])
        ok <- has_two && all(counts >= 1) && length(na.omit(vals)) >= 2
        if (ok) {
          out <- tryCatch(t.test(vals ~ trt)$p.value, error = function(e) NA_real_)
          out
        } else NA_real_
      },
      .groups = "drop"
    ) %>%
    filter(!is.na(p) & p < 0.05)
}

pvals_moist <- get_date_pvals(raw_soil, "swc_2_mean")
pvals_temp  <- get_date_pvals(raw_soil, "ts_2_mean")

# Split data by year
moist_temp_2023 <- filter(moist_temp, year == 2023)
moist_temp_2024 <- filter(moist_temp, year == 2024)

# Calculate global y-axis limits for consistent scaling within each row
global_moisture_limits <- range(moist_temp$mean_soil_moisture, na.rm = TRUE)
global_temp_limits <- range(moist_temp$mean_soil_temp, na.rm = TRUE)

# Add some padding for the star positioning
global_moisture_limits[2] <- global_moisture_limits[2] * 1.12  # 12% headroom for stars
global_temp_limits[2] <- global_temp_limits[2] * 1.12

# Calculate nice breaks for consistent tick marks
moisture_breaks <- pretty(global_moisture_limits, n = 5)
temp_breaks <- pretty(global_temp_limits, n = 5)

# Star positions - use per-date positioning but within global limits
moisture_stars <- moist_temp %>%
  group_by(year, date) %>%
  summarise(y_star = max(mean_soil_moisture, na.rm = TRUE) * 1.05, .groups = "drop") %>%
  inner_join(pvals_moist, by = c("year", "date")) %>%
  filter(is.finite(y_star))

temp_stars <- moist_temp %>%
  group_by(year, date) %>%
  summarise(y_star = max(mean_soil_temp, na.rm = TRUE) * 1.05, .groups = "drop") %>%
  inner_join(pvals_temp, by = c("year", "date")) %>%
  filter(is.finite(y_star))

# 2023 Soil Moisture (bottom left)
p1 <- ggplot(moist_temp_2023, aes(x = date, y = mean_soil_moisture, color = Treatment, shape = Treatment)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2.5) +
  scale_color_treatments() +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + Rye" = 15)) +  # circle and square
  scale_x_date(date_breaks = "1 month", date_labels = "%b",
               limits = c(as.Date("2023-01-01"), as.Date("2023-12-31"))) +
  scale_y_continuous(limits = global_moisture_limits, breaks = moisture_breaks, expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    x = "2023",
    y = "Soil Moisture (m³/m³)"
  ) +
  geom_text(data = moisture_stars %>% filter(year == 2023),
            aes(x = date, y = y_star), label = "*", color = "black", size = 8, vjust = 0, inherit.aes = FALSE) +
  theme_publication() +
  theme(
    legend.position = "none"
  )

# 2024 Soil Moisture (bottom right)
p2 <- ggplot(moist_temp_2024, aes(x = date, y = mean_soil_moisture, color = Treatment, shape = Treatment)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2.5) +
  scale_color_treatments() +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + Rye" = 15)) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b",
               limits = c(as.Date("2024-01-01"), as.Date("2024-12-31"))) +
  scale_y_continuous(limits = global_moisture_limits, breaks = moisture_breaks, expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    x = "2024",
    y = ""
  ) +
  geom_text(data = moisture_stars %>% filter(year == 2024),
            aes(x = date, y = y_star), label = "*", color = "black", size = 8, vjust = 0, inherit.aes = FALSE) +
  theme_publication() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "none"
  )

# 2023 Soil Temperature (top left)
p3 <- ggplot(moist_temp_2023, aes(x = date, y = mean_soil_temp, color = Treatment, shape = Treatment)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2.5) +
  scale_color_treatments() +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + Rye" = 15)) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b",
               limits = c(as.Date("2023-01-01"), as.Date("2023-12-31"))) +
  scale_y_continuous(limits = global_temp_limits, breaks = temp_breaks, expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    x = "",
    y = "Soil Temperature (°C)"
  ) +
  geom_text(data = temp_stars %>% filter(year == 2023),
            aes(x = date, y = y_star), label = "*", color = "black", size = 8, vjust = 0, inherit.aes = FALSE) +
  theme_publication() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "none"
  )

# 2024 Soil Temperature (top right)
p4 <- ggplot(moist_temp_2024, aes(x = date, y = mean_soil_temp, color = Treatment, shape = Treatment)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2.5) +
  scale_color_treatments() +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + Rye" = 15)) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b",
               limits = c(as.Date("2024-01-01"), as.Date("2024-12-31"))) +
  scale_y_continuous(limits = global_temp_limits, breaks = temp_breaks, expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    x = "",
    y = ""
  ) +
  geom_text(data = temp_stars %>% filter(year == 2024),
            aes(x = date, y = y_star), label = "*", color = "black", size = 8, vjust = 0, inherit.aes = FALSE) +
  theme_publication() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "none"
  )
# Arrange panels: temperature 2023/2024 on top, moisture 2023/2024 on bottom
soil_4panel <- (p3 | p4) / (p1 | p2) 

six_panel_plot <-
  (pdplot / soil_4panel) +
  patchwork::plot_layout(guides = "collect", heights = c(1, 1)) &
  theme(
    legend.position      = "top",
    legend.justification = "center",
    legend.direction     = "horizontal",
    legend.box           = "horizontal",   # keeps multiple guides in one row when possible
    legend.margin        = margin(b = 4)
  )

ggsave("figures/figure1_six_panel_weather_soil.png", six_panel_plot, width = 6.5, height = 8, dpi = 300, bg = "white")
six_panel_plot
```

Figure 1. Daily precipitation, temperature, and soil moisture over the study period. Panels show daily rainfall, air temperature, and soil moisture for each year. Shaded regions indicate historical ranges. Data are faceted by year.

# Figure 2

```{r figure-n2o-flux}
#| label: fig-n2o-flux
#| fig-cap: "Daily N2O fluxes over the study period"
#| fig-width: 10
#| fig-height: 9

# Build daily treatment means and SE for N2O flux using existing flux_data
daily_flux <- flux_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(Treatment = treatment, year = lubridate::year(date)) %>%
  filter(year %in% c(2023, 2024)) %>%
  group_by(Treatment, year, date) %>%
  summarise(
    mean_flux = mean(gnha_day_no_negative, na.rm = TRUE) / 1000,  # Convert g to kg
    se_flux   = sd(gnha_day_no_negative, na.rm = TRUE) / sqrt(sum(!is.na(gnha_day_no_negative))) / 1000,  # Convert g to kg
    .groups = "drop"
  )

# Get flux measurement date ranges for each year
flux_date_ranges <- daily_flux %>%
  group_by(year) %>%
  summarise(
    min_date = min(date, na.rm = TRUE),
    max_date = max(date, na.rm = TRUE),
    .groups = "drop"
  )

# Calculate daily significance tests between treatments
daily_significance <- flux_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(year = lubridate::year(date)) %>%
  filter(year %in% c(2023, 2024)) %>%
  group_by(year, date) %>%
  summarise(
    p_value = {
      # Get flux values for each treatment
      sorghum_flux <- gnha_day_no_negative[treatment == "Sorghum"]
      sorghum_rye_flux <- gnha_day_no_negative[treatment == "Sorghum + Rye"]

      # Remove NA values
      sorghum_flux <- sorghum_flux[!is.na(sorghum_flux)]
      sorghum_rye_flux <- sorghum_rye_flux[!is.na(sorghum_rye_flux)]

      # Perform t-test if we have enough data
      if (length(sorghum_flux) >= 2 && length(sorghum_rye_flux) >= 2) {
        tryCatch({
          t_result <- t.test(sorghum_flux, sorghum_rye_flux)
          t_result$p.value
        }, error = function(e) NA_real_)
      } else {
        NA_real_
      }
    },
    .groups = "drop"
  ) %>%
  mutate(
    significant = p_value < 0.05,
    star_label = ifelse(significant & !is.na(p_value), "*", "")
  )

# Get max flux values for star positioning
max_flux_by_date <- daily_flux %>%
  group_by(year, date) %>%
  summarise(max_flux = max(mean_flux + se_flux, na.rm = TRUE), .groups = "drop")

# Combine significance data with position data
star_data <- daily_significance %>%
  left_join(max_flux_by_date, by = c("year", "date")) %>%
  filter(star_label == "*") %>%
  mutate(star_y = max_flux * 1.1)  # Position stars 10% above the highest error bar

# Filter precipitation to match flux measurement periods only
daily_precip_trimmed <- rain %>%
  transmute(date, year, precipmm) %>%
  filter(year %in% c(2023, 2024)) %>%
  left_join(flux_date_ranges, by = "year") %>%
  filter(date >= min_date, date <= max_date) %>%
  select(date, year, precipmm)

# Print the date ranges for verification
cat("Flux measurement ranges:\n")
print(flux_date_ranges)
cat("\nPrecipitation trimmed to match flux periods\n")

# Fertilizer event dates
fert_events <- tibble(
  year = c(2023, 2024),
  fertilizer_date = as.Date(c("2023-05-05", "2024-07-17"))
)

# 1) Precipitation plot (faceted, top row) - trimmed to flux dates
precip_plot <- ggplot(daily_precip_trimmed, aes(x = date, y = precipmm)) +
  geom_col(fill = "#000000ff", color = "black", width = 1) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  scale_y_reverse(name = "Daily Precipitation (mm)") +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(x = "")

# 2) Daily flux plot (faceted, middle row)
daily_flux_plot <- ggplot(daily_flux, aes(x = date, y = mean_flux, color = Treatment)) +
  geom_line(linewidth = 1.1, alpha = 0.85) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = mean_flux - se_flux, ymax = mean_flux + se_flux),
                width = 0.2, alpha = 0.5) +
  geom_vline(data = fert_events,
             aes(xintercept = as.numeric(fertilizer_date)),
             linetype = "dashed", color = "red", alpha = 0.7, inherit.aes = FALSE) +
  geom_text(data = star_data,
            aes(x = date, y = star_y, label = star_label),
            color = "black", size = 5, inherit.aes = FALSE) +
  scale_color_treatments() +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  labs(y = expression("Daily N"[2]*"O Flux (g N ha"^-1*" day"^-1*")"),
       color = "Treatment") +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.text = element_blank(),
    legend.position = "none"  # Hide strip text for middle row
  ) +
  labs(x = "")

# 3) Build cumulative flux data (both years combined for faceting)
cum_flux_combined <- daily_flux %>%
  arrange(Treatment, year, date) %>%
  group_by(Treatment, year) %>%
  # Use actual measurement date ranges instead of full calendar year
  left_join(flux_date_ranges, by = "year") %>%
  summarise(
    start_date = first(min_date),
    end_date = first(max_date),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(all_dates = list(seq.Date(start_date, end_date, by = "day"))) %>%
  unnest(all_dates) %>%
  rename(date = all_dates) %>%
  select(-start_date, -end_date) %>%
  # Join with observed data
  left_join(daily_flux, by = c("Treatment", "year", "date")) %>%
  mutate(has_sample = !is.na(mean_flux)) %>%
  group_by(Treatment, year) %>%
  # Interpolate within observed ranges only (rule = 1)
  mutate(
    mean_flux_interp = approx(
      x = date[!is.na(mean_flux)],
      y = mean_flux[!is.na(mean_flux)],
      xout = date, rule = 1, ties = "ordered"
    )$y,
    se_flux_interp = approx(
      x = date[!is.na(se_flux)],
      y = se_flux[!is.na(se_flux)],
      xout = date, rule = 1, ties = "ordered"
    )$y
  ) %>%
  # Filter to only include dates within measurement range
  filter(!is.na(mean_flux_interp)) %>%
  # Calculate cumulative
  mutate(
    cum_flux = cumsum(mean_flux_interp),
    cum_se = sqrt(cumsum(se_flux_interp^2))
  ) %>%
  ungroup()

# 4) Cumulative flux plot (faceted, bottom row with x-axis labels)
cumulative_flux_plot <- ggplot(cum_flux_combined, aes(x = date, y = cum_flux, color = Treatment, fill = Treatment)) +
  geom_ribbon(aes(ymin = pmax(cum_flux - cum_se, 0), ymax = cum_flux + cum_se),
              alpha = 0.2, linewidth = 0) +
  geom_line(linewidth = 1.1) +
  scale_color_treatments() +
  scale_fill_treatments() +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  labs(x = "Month", 
       y = expression("Cumulative N"[2]*"O Flux (g N ha"^-1*")"),
       color = "Treatment", fill = "Treatment") +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    strip.text = element_blank(),  # Hide strip text for bottom row
    legend.position = "bottom",
    legend.direction = "horizontal",
    strip.background = element_rect(fill = alpha("#A5CAD2", 0.2)),
    panel.spacing = unit(2, "lines")
  )

# Assemble final figure: 3 faceted rows
figure2 <- (precip_plot / daily_flux_plot / cumulative_flux_plot) +
  patchwork::plot_layout(heights = c(0.8, 1, 1.2))

figure2

ggsave("figures/figure2_daily_flux_precip_cumulative_2023_2024.png",
       figure2, width = 10, height = 9, dpi = 300, bg = "white")
```

Figure 2. Daily and cumulative N₂O fluxes and precipitation by year. Top panels: Daily N₂O flux and precipitation, trimmed to measurement windows. Middle panels: Daily N₂O flux with asterisks (\*) indicating dates where flux differs significantly between treatments (p \< 0.05). Bottom panels: Cumulative N₂O flux. Faceted by year. Colors indicate treatment. Axes are aligned for direct comparison.

## Figure 2 Alternative: Dual-Axis Version

```{r figure-2-dual-axis}
#| label: fig-n2o-flux-dual-axis
#| fig-cap: "Daily and cumulative N2O flux with precipitation on dual axes"
#| fig-width: 10
#| fig-height: 8

# Create dual-axis plots for each year
# Create dual-axis plots for each year
# First calculate global maxima for consistent y-axes
global_max_flux <- max(daily_flux$mean_flux + daily_flux$se_flux, na.rm = TRUE)
global_max_precip <- max(daily_precip_trimmed$precipmm, na.rm = TRUE)
global_max_cum_flux <- max(cum_flux_combined$cum_flux + cum_flux_combined$cum_se, na.rm = TRUE)

# Scale precipitation to fit on flux scale, positioned from top down
global_precip_scale_factor <- global_max_flux * 0.4 / global_max_precip
global_plot_top <- global_max_flux * 1.1

create_dual_axis_plot <- function(year_val, is_right_panel = FALSE) {
  # Filter data for the specific year
  flux_year <- daily_flux %>% filter(year == year_val)
  precip_year <- daily_precip_trimmed %>% filter(year == year_val)
  star_year <- star_data %>% filter(year == year_val)
  fert_year <- fert_events %>% filter(year == year_val)
  cum_flux_year <- cum_flux_combined %>% filter(year == year_val)
  cum_flux_points <- cum_flux_year %>% filter(has_sample)

  # Get date range for this year
  date_range <- flux_date_ranges %>% filter(year == year_val)

  # Daily flux plot with precipitation
  daily_plot <- ggplot() +
    # Precipitation bars (from top down, above the data)
    geom_rect(data = precip_year,
              aes(xmin = date - 0.5, xmax = date + 0.5,
                  ymin = global_plot_top - precipmm * global_precip_scale_factor, ymax = global_plot_top),
              fill = "#377EB8", alpha = 0.7) +

    # Daily flux lines and points
    #geom_line(data = flux_year,
     #         aes(x = date, y = mean_flux, color = Treatment),
      #        linewidth = 1.1, alpha = 0.85) +
    geom_point(data = flux_year,
               aes(x = date, y = mean_flux, color = Treatment),
               size = 2) +
    geom_errorbar(data = flux_year,
                  aes(x = date, ymin = mean_flux - se_flux, ymax = mean_flux + se_flux, color = Treatment),
                  width = 0.2, alpha = 0.5) +

    # Fertilizer events
    geom_vline(data = fert_year,
               aes(xintercept = as.numeric(fertilizer_date)),
               linetype = "dashed", color = "red", alpha = 0.7) +

    # Significance stars
    geom_text(data = star_year,
              aes(x = date, y = star_y, label = star_label),
              color = "black", size = 8) +

    # Scales and styling
    scale_color_treatments() +
    guides(color = "none") +
    scale_x_date(date_breaks = "1 month", date_labels = "%b",
                 limits = c(date_range$min_date, date_range$max_date)) +

    # Primary y-axis (flux), using global limits for consistency
    scale_y_continuous(
      name = if (!is_right_panel) expression("Daily N"[2]*"O Flux (kg N ha"^-1*" day"^-1*")") else "",
      limits = c(0, global_plot_top),
      sec.axis = sec_axis(~ (global_plot_top - .) / global_precip_scale_factor,
                          name = if (is_right_panel) "Daily Precipitation (mm)" else "")
    ) +

    # Theme and labels
    theme_publication() +
    theme(
      legend.position = "none",
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      # Remove y-axis elements for right panel
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text(),
      # Remove secondary y-axis elements for left panel
      axis.text.y.right = if (is_right_panel) element_text(color = "#377EB8") else element_blank(),
      axis.ticks.y.right = if (is_right_panel) element_line() else element_blank(),
      axis.title.y.right = if (is_right_panel) element_text(color = "#377EB8") else element_blank()
    ) +
    labs(
      title = paste("", year_val),
      x = ""
    ) +

    # Add horizontal line at y=0 for reference
    geom_hline(yintercept = 0, linetype = "solid", alpha = 0.3)

  # Cumulative flux plot (bottom panel with x-axis labels)
  cumulative_plot <- ggplot(cum_flux_year, aes(x = date, y = cum_flux, color = Treatment)) +
    geom_ribbon(aes(ymin = pmax(cum_flux - cum_se, 0), ymax = cum_flux + cum_se, fill = Treatment),
                alpha = 0.2, linewidth = 0) +
    geom_line(linewidth = 1.1) +
    geom_point(data = cum_flux_points, aes(x = date, y = cum_flux, color = Treatment), size = 1.8) +
    scale_color_treatments() +
    scale_fill_treatments() +
    scale_x_date(date_breaks = "1 month", date_labels = "%b",
                 limits = c(date_range$min_date, date_range$max_date)) +
    scale_y_continuous(
      name = if (!is_right_panel) expression("Cumulative N"[2]*"O Flux (kg N ha"^-1*")") else "",
      limits = c(0, global_max_cum_flux)
    ) +
    labs(x = "Month") +
    theme_publication() +
    theme(
      legend.position = "none",
      # Remove y-axis elements for right panel
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text()
    )

  # Combine daily and cumulative plots vertically
  combined_plot <- (daily_plot / cumulative_plot) +
    patchwork::plot_layout(heights = c(1.2, 1))

  return(combined_plot)
}

# Create plots for both years
plot_2023 <- create_dual_axis_plot(2023, is_right_panel = FALSE)
plot_2024 <- create_dual_axis_plot(2024, is_right_panel = TRUE)

# Combine plots side by side
figure2_dual_axis <- (plot_2023 | plot_2024) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom", 
        legend.justification = "center",
        legend.box.just = "center")

figure2_dual_axis

# Save the dual-axis version
ggsave("figures/figure2_dual_axis_flux_precip_cumulative_2023_2024v2.png",
       figure2_dual_axis, width = 6.5, height = 8, dpi = 300, bg = "white")
```

Figure 2 Alternative. Daily and cumulative N₂O flux with precipitation on dual axes by year. Top panels: Daily N₂O flux with precipitation bars "raining down" from the top (blue, right y-axis) and daily N₂O flux plotted along the bottom axis (colored lines, left y-axis). Asterisks (\*) indicate dates where flux differs significantly between treatments (p \< 0.05). Red dashed lines show fertilizer application dates. Bottom panels: Cumulative N₂O flux. X-axes are aligned between daily and cumulative panels for direct comparison.

# Figure 3: Nitrogen Leaching

```{r figure-leaching}
#| label: fig-leaching
#| fig-cap: "Tile-drain nitrogen loss and cumulative leaching"
#| fig-width: 10
#| fig-height: 9

# Build daily treatment means and SE for leaching (like Figure 2 does for flux)
# Ensure plot area is available in this chunk (avoid dependency on earlier cells)
plot_area_ft2 <- 120 * 160
plot_area_ha <- plot_area_ft2 / 107639.1041671

daily_leaching <- leaching_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(
    daily_n_loss_kgha = (total_n_loss_mg / 1e6) / plot_area_ha
  ) %>%
  group_by(plot, treatment, year, date) %>%
  summarise(
    daily_loss = mean(daily_n_loss_kgha, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(plot, treatment, year, date)

# Calculate treatment means and SE for daily losses
daily_leaching_summary <- daily_leaching %>%
  group_by(treatment, year, date) %>%
  summarise(
    mean_loss = mean(daily_loss, na.rm = TRUE),
    se_loss = sd(daily_loss, na.rm = TRUE) / sqrt(sum(!is.na(daily_loss))),
    .groups = "drop"
  )

# Get leaching measurement date ranges for each year (FROM the processed data like Figure 2)
leaching_date_ranges <- daily_leaching_summary %>%
  group_by(year) %>%
  summarise(
    min_date = min(date, na.rm = TRUE),
    max_date = max(date, na.rm = TRUE),
    .groups = "drop"
  )

print(leaching_date_ranges)

# Build cumulative leaching with robust handling for sparse observations
cum_leaching_combined <- daily_leaching_summary %>%
  arrange(treatment, year, date) %>%
  group_by(treatment, year) %>%
  group_modify(~{
    df <- .x
    if (nrow(df) == 0) return(tibble())
    # Date span limited to observed range
    start_date <- min(df$date, na.rm = TRUE)
    end_date   <- max(df$date, na.rm = TRUE)
    all_dates  <- tibble(date = seq.Date(start_date, end_date, by = "day"))
    df_full <- all_dates %>% left_join(df, by = "date")
    # Interpolate within range when >= 2 points, otherwise treat missing days as 0 (to avoid blank figure)
    n_pts <- sum(!is.na(df$mean_loss))
    if (n_pts >= 2) {
      mean_loss_interp <- approx(x = df$date[!is.na(df$mean_loss)], y = df$mean_loss[!is.na(df$mean_loss)],
                                 xout = df_full$date, rule = 1, ties = "ordered")$y
      se_loss_interp   <- approx(x = df$date[!is.na(df$se_loss)], y = df$se_loss[!is.na(df$se_loss)],
                                 xout = df_full$date, rule = 1, ties = "ordered")$y
      df_full <- df_full %>% mutate(
        mean_loss_interp = mean_loss_interp,
        se_loss_interp   = se_loss_interp
      )
    } else {
      df_full <- df_full %>% mutate(
        mean_loss_interp = replace_na(mean_loss, 0),
        se_loss_interp   = replace_na(se_loss, 0)
      )
    }
    df_full %>%
      mutate(
        cum_loss = cumsum(replace_na(mean_loss_interp, 0)),
        cum_se   = sqrt(cumsum(replace_na(se_loss_interp, 0)^2))
      )
  }) %>%
  ungroup()

min(cum_leaching_combined$date)
max(cum_leaching_combined$date)

# Prepare faceted monthly data (like Figure 2)
monthly_leaching_faceted <- daily_leaching_summary %>%
  mutate(month_year = floor_date(date, "month")) %>%
  group_by(treatment, year, month_year) %>%
  summarise(
    monthly_total = sum(mean_loss, na.rm = TRUE),
    monthly_se = sqrt(sum(se_loss^2, na.rm = TRUE)),
    .groups = "drop"
  )

min(monthly_leaching_faceted$month_year)
max(monthly_leaching_faceted$month_year)

# 1) Monthly leaching plot (top row) - faceted like Figure 2
monthly_plot <- ggplot(monthly_leaching_faceted, aes(x = month_year, y = monthly_total, fill = treatment)) +
  geom_col(position = position_dodge(width = 20), width = 15) +
  geom_errorbar(aes(ymin = pmax(monthly_total - monthly_se, 0), ymax = monthly_total + monthly_se),
                position = position_dodge(width = 20), width = 5) +
  scale_fill_treatments() +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  labs(y = expression("Monthly N Loss (kg N ha"^-1*")"), fill = "Treatment") +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "none"
  ) +
  labs(x = "")


# 2) Cumulative leaching plot (bottom row) - faceted like Figure 2
# Also compute observed cumulative points for visibility when sparse
obs_points <- daily_leaching_summary %>%
  group_by(treatment, year) %>%
  arrange(date) %>%
  mutate(cum_obs = cumsum(replace_na(mean_loss, 0))) %>%
  ungroup()

cumulative_leaching_plot <- ggplot(cum_leaching_combined, aes(x = date, y = cum_loss, color = treatment, fill = treatment)) +
  geom_ribbon(aes(ymin = pmax(cum_loss - cum_se, 0), ymax = cum_loss + cum_se),
              alpha = 0.2, linewidth = 0) +
  geom_line(linewidth = 1.1) +
  # Show observed points for visibility when data are sparse
  geom_point(data = obs_points, inherit.aes = FALSE,
             aes(x = date, y = cum_obs, color = treatment),
             alpha = 0.5, shape = 16, size = 1.2) +
  scale_color_treatments() +
  scale_fill_treatments() +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  labs(x = "Month", 
       y = expression("Cumulative N Loss (kg N ha"^-1*")"),
       color = "Treatment", fill = "Treatment") +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    strip.text = element_blank(),  # Hide strip text for bottom row
    legend.position = "bottom",
    legend.direction = "horizontal",
    strip.background = element_rect(fill = alpha("#A5CAD2", 0.2)),
    panel.spacing = unit(2, "lines")
  )
# Assemble final figure: 2 faceted rows like Figure 2
figure3 <- (monthly_plot / cumulative_leaching_plot) +
  patchwork::plot_layout(heights = c(1, 1.2))

figure3

ggsave("figures/figure3_leaching_four_panel.png", figure3, width = 6.5, height = 9, dpi = 300, bg = "white")
```

Figure 3. Monthly and cumulative nitrogen leaching by year. Top panels: Monthly leaching losses (kg N ha⁻¹) by treatment. Bottom panels: Cumulative leaching losses. Faceted by year. Axes are aligned for direct comparison. Letters indicate Tukey-adjusted significance groups; treatments sharing a letter are not significantly different ( 𝛼 = 0.05 α=0.05).

## Figure 3 Alternative: Dual-Axis Version

```{r figure-3-dual-axis}
#| label: fig-leaching-dual-axis
#| fig-cap: "Daily nitrogen leaching and precipitation on dual axes with cumulative leaching"
#| fig-width: 10
#| fig-height: 8

# Calculate daily significance tests for leaching between treatments
daily_leaching_significance <- leaching_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(
    year = lubridate::year(date),
    daily_n_loss_kgha = (total_n_loss_mg / 1e6) / plot_area_ha
  ) %>%
  filter(year %in% c(2023, 2024)) %>%
  group_by(year, date) %>%
  summarise(
    p_value = {
      # Get leaching values for each treatment
      sorghum_loss <- daily_n_loss_kgha[treatment == "Sorghum"]
      sorghum_rye_loss <- daily_n_loss_kgha[treatment == "Sorghum + Rye"]

      # Remove NA values
      sorghum_loss <- sorghum_loss[!is.na(sorghum_loss)]
      sorghum_rye_loss <- sorghum_rye_loss[!is.na(sorghum_rye_loss)]

      # Perform t-test if we have enough data
      if (length(sorghum_loss) >= 2 && length(sorghum_rye_loss) >= 2) {
        tryCatch({
          t_result <- t.test(sorghum_loss, sorghum_rye_loss)
          t_result$p.value
        }, error = function(e) NA_real_)
      } else {
        NA_real_
      }
    },
    .groups = "drop"
  ) %>%
  mutate(
    significant = p_value < 0.05,
    star_label = ifelse(significant & !is.na(p_value), "*", "")
  )

# Get max leaching values for star positioning
max_leaching_by_date <- daily_leaching_summary %>%
  group_by(year, date) %>%
  summarise(max_loss = max(mean_loss + se_loss, na.rm = TRUE), .groups = "drop")

# Combine significance data with position data for leaching
leaching_star_data <- daily_leaching_significance %>%
  left_join(max_leaching_by_date, by = c("year", "date")) %>%
  filter(star_label == "*") %>%
  mutate(star_y = max_loss * 1.1)  # Position stars 10% above the highest error bar

# CRITICAL FIX: Get actual measurement date ranges from RAW leaching data
# This finds the first and last dates where we actually have leaching measurements
actual_leaching_date_ranges <- leaching_data %>%
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) %>%
  mutate(year = lubridate::year(date)) %>%
  filter(year %in% c(2023, 2024), !is.na(total_n_loss_mg)) %>%
  group_by(year) %>%
  summarise(
    min_date = min(date, na.rm = TRUE),
    max_date = max(date, na.rm = TRUE),
    .groups = "drop"
  )

cat("Actual leaching measurement date ranges:\n")
print(actual_leaching_date_ranges)

# Filter precipitation to match ACTUAL leaching measurement periods
daily_precip_leaching <- rain %>%
  transmute(date, year, precipmm) %>%
  filter(year %in% c(2023, 2024)) %>%
  left_join(actual_leaching_date_ranges, by = "year") %>%
  filter(date >= min_date, date <= max_date) %>%
  select(date, year, precipmm)

# CRITICAL FIX: Subset cumulative data to match actual measurement date range
cum_leaching_trimmed <- cum_leaching_combined %>%
  left_join(actual_leaching_date_ranges, by = "year") %>%
  filter(date >= min_date, date <= max_date) %>%
  select(-min_date, -max_date)

# Also trim observed points to match
obs_points_trimmed <- obs_points %>%
  left_join(actual_leaching_date_ranges, by = "year") %>%
  filter(date >= min_date, date <= max_date) %>%
  select(-min_date, -max_date)

# Create dual-axis plots for each year (leaching version)
# First calculate global maxima for consistent y-axes
global_max_loss <- max(daily_leaching_summary$mean_loss + daily_leaching_summary$se_loss, na.rm = TRUE)
global_max_precip_leaching <- max(daily_precip_leaching$precipmm, na.rm = TRUE)

# Scale precipitation to fit on loss scale, positioned from top down
global_precip_scale_factor_leaching <- global_max_loss * 0.4 / global_max_precip_leaching
global_plot_top_leaching <- global_max_loss * 1.1

create_leaching_dual_axis_plot <- function(year_val, is_right_panel = FALSE) {
  # Filter data for the specific year
  leaching_year <- daily_leaching_summary %>% filter(year == year_val)
  precip_year <- daily_precip_leaching %>% filter(year == year_val)
  star_year <- leaching_star_data %>% filter(year == year_val)

  # Get date range for this year - use ACTUAL measurement range
  date_range <- actual_leaching_date_ranges %>% filter(year == year_val)

  # Create the plot
  p <- ggplot() +
    # Precipitation bars (from top down, above the data)
    geom_rect(data = precip_year,
              aes(xmin = date - 0.5, xmax = date + 0.5,
                  ymin = global_plot_top_leaching - precipmm * global_precip_scale_factor_leaching, ymax = global_plot_top_leaching),
              fill = "#377EB8", alpha = 0.7) +

    # Daily leaching lines and points
    geom_line(data = leaching_year,
              aes(x = date, y = mean_loss, color = treatment),
              linewidth = 1.1, alpha = 0.85) +
    geom_point(data = leaching_year,
               aes(x = date, y = mean_loss, color = treatment),
               size = 2) +
    geom_errorbar(data = leaching_year,
                  aes(x = date, ymin = mean_loss - se_loss, ymax = mean_loss + se_loss, color = treatment),
                  width = 0.2, alpha = 0.5) +

    # Significance stars
    geom_text(data = star_year,
              aes(x = date, y = star_y, label = star_label),
              color = "black", size = 8) +

    # Scales and styling
    scale_color_treatments() +
    guides(color = "none") +
    scale_x_date(date_breaks = "1 month", date_labels = "%b",
                 limits = c(date_range$min_date, date_range$max_date)) +

    # Primary y-axis (leaching), using global limits for consistency
    scale_y_continuous(
      name = if (!is_right_panel) expression("Daily N Loss (kg N ha"^-1*" day"^-1*")") else "",
      limits = c(0, global_plot_top_leaching),
      sec.axis = sec_axis(~ (global_plot_top_leaching - .) / global_precip_scale_factor_leaching,
                          name = if (is_right_panel) "Daily Precipitation (mm)" else "")
    ) +

    # Theme and labels
    theme_publication() +
    theme(
      legend.position = "none",
      # Remove x-axis elements for top panel (like Figure 2)
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      # Remove y-axis elements for right panel
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text(),
      # Remove secondary y-axis elements for left panel
      axis.text.y.right = if (is_right_panel) element_text(color = "#377EB8") else element_blank(),
      axis.ticks.y.right = if (is_right_panel) element_line() else element_blank(),
      axis.title.y.right = if (is_right_panel) element_text(color = "#377EB8") else element_blank()
    ) +
    labs(
      title = paste("", year_val),
      x = ""  # Remove x label for top panel
    ) +

    # Add horizontal line at y=0 for reference
    geom_hline(yintercept = 0, linetype = "solid", alpha = 0.3)

  return(p)
}

# Create daily leaching plots for both years
daily_plot_2023 <- create_leaching_dual_axis_plot(2023, is_right_panel = FALSE)
daily_plot_2024 <- create_leaching_dual_axis_plot(2024, is_right_panel = TRUE)

# Combine daily plots side by side
daily_leaching_dual_axis <- (daily_plot_2023 | daily_plot_2024) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom", 
        legend.justification = "center",
        legend.box.just = "center")

# CRITICAL FIX: Modify cumulative plot to use trimmed data and matching x-axis limits
cumulative_leaching_plot_clean <- ggplot(cum_leaching_trimmed, aes(x = date, y = cum_loss, color = treatment, fill = treatment)) +
  geom_ribbon(aes(ymin = pmax(cum_loss - cum_se, 0), ymax = cum_loss + cum_se),
              alpha = 0.2, linewidth = 0) +
  geom_line(linewidth = 1.1) +
  # Show observed points for visibility when data are sparse - use trimmed data
  geom_point(data = obs_points_trimmed, inherit.aes = FALSE,
             aes(x = date, y = cum_obs, color = treatment),
             alpha = 0.5, shape = 16, size = 1.2) +
  scale_color_treatments() +
  scale_fill_treatments() +
  # Use SAME x-axis settings as daily plots for perfect alignment
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  labs(x = "Month",
       y = expression("Cumulative N Loss (kg N ha"^-1*")")) +
  facet_wrap(~year, nrow = 1, scales = "free_x") +
  theme_publication() +
  theme(
    strip.text = element_blank(),  # Hide strip text for consistency with Figure 2
    legend.position = "none",  # Hide legend since it's collected above
    strip.background = element_rect(fill = alpha("#A5CAD2", 0.2)),
    panel.spacing = unit(2, "lines")
  )

# Assemble final figure: daily dual-axis on top, cumulative below (like Figure 2)
figure3_dual_axis <- (daily_leaching_dual_axis / cumulative_leaching_plot_clean) +
  patchwork::plot_layout(heights = c(1.2, 1))

figure3_dual_axis

# Save the dual-axis version
ggsave("figures/figure3_dual_axis_leaching_precip_2023_2024.png",
       figure3_dual_axis, width = 6.5, height = 8, dpi = 300, bg = "white")
```

Figure 3 Alternative. Daily nitrogen leaching and precipitation on dual axes with cumulative leaching by year. Top panels: Daily nitrogen leaching with precipitation bars "raining down" from the top (light blue, right y-axis) and daily nitrogen loss plotted along the bottom axis (colored lines, left y-axis). Asterisks (\*) indicate dates where leaching differs significantly between treatments (p \< 0.05). Bottom panels: Cumulative nitrogen leaching. Faceted by year with consistent styling to Figure 2.

# Figure 4: Annual Nitrogen Losses

```{r figure-annual-loss}
#| label: fig-annual-loss
#| fig-width: 10
#| fig-height: 6

# Summaries for annual leaching and N2O (reuse Table 3 summaries for consistency)
leach_summary_fig4 <- leaching_summary %>%
  transmute(treatment, year, mean_leach = mean_leaching,
            se_leach = sd_leaching / sqrt(n_plots))

n2o_summary_fig4 <- n2o_summary %>%
  transmute(treatment, year, mean_n2o,
            se_n2o = sd_n2o / sqrt(n_plots))

# Compute per-year Tukey letters for leaching (reuse helper used in Table 3)
leach_letters_fig4 <- annual_leaching %>%
  group_by(year) %>%
  group_modify(~ compute_letters_by_year(.x, "annual_cumulative_leaching")) %>%
  ungroup()

# Combine summaries
combined_loss <- full_join(leach_summary_fig4, n2o_summary_fig4, by = c("treatment", "year"))

loss_long <- combined_loss %>%
  pivot_longer(cols = c(mean_leach, mean_n2o), names_to = "component", values_to = "value") %>%
  mutate(
    se = if_else(component == "mean_leach", se_leach, se_n2o),
    component = recode(component, mean_leach = "Leached N", mean_n2o = "Nitrous Oxide"),
    treatment = factor(treatment, levels = c("Corn", "Soy", "Sorghum", "Sorghum + Rye"))
  )

loss_colors <- c("Leached N" = "#0A2E57FF", "Nitrous Oxide" = "#95C36EFF")

# Top-of-bar positions for letter placement
max_total <- loss_long %>%
  group_by(year, treatment) %>%
  summarise(total = sum(value, na.rm = TRUE), .groups = "drop_last") %>%
  summarise(max_total = max(total, na.rm = TRUE), .groups = "drop") %>%
  pull(max_total)

letters_pos <- combined_loss %>%
  mutate(total = coalesce(mean_leach, 0) + coalesce(mean_n2o, 0)) %>%
  left_join(leach_letters_fig4, by = c("treatment", "year")) %>%
  mutate(y = total + 0.03 * max_total) %>%
  select(year, treatment, letter, y)

figure4 <- ggplot(loss_long, aes(x = treatment, y = value, fill = component)) +
  geom_col(width = 0.7) +
  # add leaching letters above stacked bars (per year)
  geom_text(data = letters_pos, aes(x = treatment, y = y, label = letter),
            inherit.aes = FALSE, size = 5) +
  facet_wrap(~year, nrow = 1) +
  scale_fill_manual(values = loss_colors, name = "Loss Type") +
 # scale_y_continuous(limits = c(0, max_total * 1.08), expand = expansion(mult = c(0, 0.05))) +
  labs(x = "Treatment", y = expression("Annual N loss (kg N ha"^{-1}*")")) +
  theme_publication() +
  theme(legend.position = "top")

figure4

ggsave("figures/figure4_stacked_n_loss.png", figure4, width = 8.5, height = 6, dpi = 300, bg = "white")
```

Figure 4. Stacked annual nitrogen losses by treatment. Bars show mean annual N₂O and leaching losses (kg N ha⁻¹) by treatment and year. Letters indicate Tukey-adjusted significance groups; treatments sharing a letter are not significantly different ( 𝛼 = 0.05 α=0.05). \## Statistical summaries for annual losses

```{r}
annual_leaching %>% count(year, treatment)
plot_cumulative_n2o %>% count(year, treatment)

annual_leaching %>%
  group_by(year, treatment) %>%
  summarise(n = n(), n_non_na = sum(!is.na(annual_cumulative_leaching)), .groups = "drop")

plot_cumulative_n2o %>%
  group_by(year, treatment) %>%
  summarise(n = n(), n_non_na = sum(!is.na(annual_cumulative_n2o)), .groups = "drop")

letters_leach
letters_n2o
letters_leach %>% filter(treatment == "Corn")
letters_n2o   %>% filter(treatment == "Corn")

annual_leaching %>%
  group_by(year, treatment) %>%
  summarise(mean = mean(annual_cumulative_leaching), sd = sd(annual_cumulative_leaching),
            se = sd / sqrt(n()), .groups = "drop")

plot_cumulative_n2o %>%
  group_by(year, treatment) %>%
  summarise(mean = mean(annual_cumulative_n2o), sd = sd(annual_cumulative_n2o),
            se = sd / sqrt(n()), .groups = "drop")

# Leaching
split(annual_leaching, annual_leaching$year) |>
  lapply(\(d) pairwise.t.test(d$annual_cumulative_leaching, d$treatment, p.adjust.method = "none"))

# N2O
split(plot_cumulative_n2o, plot_cumulative_n2o$year) |>
  lapply(\(d) pairwise.t.test(d$annual_cumulative_n2o, d$treatment, p.adjust.method = "none"))
```

# Biomass and grain yeild

```{r biomass-yield}
#| label: biomass-yield
#| fig-cap: "Sorghum crop biomass and soy and corn grain yield"  



```

We are waiting on C:N data from the lab to complete this section.

# Summary

This document provides clean, efficient analysis following tidyverse principles:

-   **Consistent data processing** using `group_by()` and `summarise()`
-   **Functional programming** with custom helper functions
-   **Clear separation** between data processing and visualization
-   **Reproducible workflow** with proper chunk organization
-   **Professional styling** consistent across all outputs

Each table and figure is generated in its own chunk for modularity and clarity.

## Patched Figures (2025-09-16 meeting actions)

```{r figure1-soil-moisture-sigbar, message=FALSE, warning=FALSE}
#| label: fig-soil-moisture
#| fig-cap: "Soil moisture by treatment with top-of-panel significance segments (colored where treatments differ, α = 0.05)."
#| fig-width: 10
#| fig-height: 5.5

MOISTURE_COL <- if (exists("MOISTURE_COL")) MOISTURE_COL else "vwc"

library(lme4); library(emmeans); library(dplyr); library(ggplot2); library(scales)

soil_sig <- soil_data %>%
  dplyr::filter(treatment %in% c("Sorghum","Sorghum + Rye"),
         !is.na(.data[[MOISTURE_COL]])) %>%
  group_by(date) %>%
  summarize(
    p_value = {
      ok <- FALSE; p <- NA_real_; est <- NA_real_
      try({
        m <- lmer(as.formula(paste(MOISTURE_COL, "~ treatment + (1|block/plot)")), data = cur_data())
        em <- emmeans(m, "treatment")
        ct <- contrast(em, "pairwise") %>% summary(infer=TRUE)
        p <- ct$p.value[1]; est <- ct$estimate[1]; ok <- TRUE
      }, silent=TRUE)
      if (!ok) {
        tt <- try(t.test(
          cur_data() |> filter(treatment == "Sorghum") |> pull(.data[[MOISTURE_COL]]),
          cur_data() |> filter(treatment == "Sorghum + Rye") |> pull(.data[[MOISTURE_COL]])
        ), silent=TRUE)
        if (!inherits(tt,"try-error")) {
          p <- tt$p.value; est <- unname(diff(rev(tt$estimate)))
        }
      }
      p
    },
    estimate = if (exists("est")) est else NA_real_,
    .groups = "drop"
  ) %>%
  mutate(
    sig = !is.na(p_value) & p_value < 0.05,
    who_higher = case_when(!sig ~ "ns", estimate > 0 ~ "Sorghum higher",
                           estimate < 0 ~ "Sorghum+Rye higher", TRUE ~ "ns")
  ) %>% arrange(date) %>% mutate(run = rleid(who_higher))

soil_sig_runs <- soil_sig %>% filter(who_higher != "ns") %>%
  group_by(who_higher, run) %>% summarise(xmin = min(date), xmax = max(date), .groups = "drop")

base_moisture_plot <- ggplot(soil_data %>% filter(treatment %in% c("Sorghum","Sorghum + Rye")),
                             aes(date, .data[[MOISTURE_COL]], color = treatment)) +
  geom_line(alpha = 0.8) + theme_publication() +
  labs(y = "Volumetric water content (m³ m⁻³)", x = NULL, color = "Treatment")

moisture_plot_sigbar <- base_moisture_plot +
  coord_cartesian(clip = "off") +
  annotate("segment", x = min(soil_data$date, na.rm=TRUE), xend = max(soil_data$date, na.rm=TRUE),
           y = Inf, yend = Inf, colour = "grey70", linewidth = 2) +
  geom_segment(data = soil_sig_runs,
               aes(x = xmin, xend = xmax, y = Inf, yend = Inf, colour = who_higher),
               linewidth = 3, inherit.aes = FALSE) +
  scale_colour_manual(values = c("Sorghum" = "#D55E00","Sorghum + Rye"="#0072B2",
                                 "Sorghum higher"="#D55E00","Sorghum+Rye higher"="#0072B2")) +
  theme(plot.margin = margin(10, 20, 10, 10), legend.position = "bottom")

moisture_plot_sigbar
```

```{r supp-moisture-delta-bars, message=FALSE, warning=FALSE}
#| label: fig-supp-moisture-delta
#| fig-cap: "Supplemental: Δ soil moisture (Sorghum+Rye − Sorghum); separate weather panel and delta bars."
#| fig-width: 10
#| fig-height: 6

library(patchwork)
MOISTURE_COL <- if (exists("MOISTURE_COL")) MOISTURE_COL else "vwc"

supp_delta <- soil_data %>%
  filter(treatment %in% c("Sorghum","Sorghum + Rye")) %>%
  group_by(date) %>%
  summarise(
    vwc_S   = mean(.data[[MOISTURE_COL]][treatment == "Sorghum"], na.rm = TRUE),
    vwc_SR  = mean(.data[[MOISTURE_COL]][treatment == "Sorghum + Rye"], na.rm = TRUE),
    delta   = vwc_SR - vwc_S, .groups = "drop"
  )

p_delta <- ggplot(supp_delta, aes(date, delta)) +
  geom_col(width = 0.9) + geom_hline(yintercept = 0, colour = "grey60") +
  theme_publication() + labs(y = "Δ VWC (S+R − S)", x = NULL) +
  scale_x_date(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(breaks = pretty_breaks_int(6))

# If you have an existing weather_daily object with precip/temp, reuse.
p_weather <- ggplot(weather_daily, aes(date, precip_mm)) +
  geom_col() + theme_publication() + labs(y = "Precipitation (mm·d⁻¹)", x = NULL) +
  scale_y_continuous(breaks = pretty_breaks_int(6))

p_weather / p_delta + plot_layout(heights = c(2, 3))
```

```{r figs-2-3-sampling-points, message=FALSE, warning=FALSE}
#| label: fig-sampling-overlay
#| fig-cap: "Sampling days highlighted: points on daily panels and markers on cumulative curves."
#| fig-width: 10
#| fig-height: 8

# Detect sampling dates from flux_data by default
sampling_dates <- flux_data %>% distinct(date) %>% arrange(date) %>% pull(date)

p_flux_daily <- ggplot(daily_flux, aes(date, mean, colour = Treatment)) +
  geom_line() + geom_point(size = 1.6) +
  geom_ribbon(aes(ymin = mean - se, ymax = mean + se, fill = Treatment),
              alpha = 0.15, colour = NA) +
  theme_publication() +
  labs(y = expression(N[2]*O~(g~N~ha^-1~d^-1)), x = NULL, colour = "Treatment", fill = "Treatment") +
  scale_x_date(breaks = sampling_dates, labels = scales::label_date("%b %d"))

p_flux_cum <- ggplot(cum_flux, aes(date, cumulative, colour = Treatment)) +
  geom_line(linewidth = 1) +
  geom_point(data = daily_flux %>% filter(date %in% sampling_dates),
             aes(date, cumsum(mean)), size = 1.6, inherit.aes = FALSE) +
  theme_publication() +
  labs(y = expression(Cumulative~N[2]*O~(g~N~ha^-1)), x = NULL, colour = "Treatment") +
  scale_x_date(breaks = sampling_dates, labels = scales::label_date("%b %d"))

p_flux_daily / p_flux_cum
```

```{r delta-diagnostics, message=FALSE, warning=FALSE}
#| label: fig-delta-diagnostics
#| fig-cap: "ΔN₂O flux vs Δsoil moisture and temperature diagnostics."
#| fig-width: 10
#| fig-height: 5

daily_moist <- soil_data %>%
  filter(treatment %in% c("Sorghum","Sorghum + Rye")) %>%
  group_by(date, treatment) %>%
  summarise(vwc = mean(.data[[if (exists("MOISTURE_COL")) MOISTURE_COL else "vwc"]], na.rm = TRUE),
            .groups = "drop") %>%
  tidyr::pivot_wider(names_from = treatment, values_from = vwc) %>%
  mutate(delta_vwc = `Sorghum + Rye` - Sorghum)

daily_temp <- weather_daily %>% group_by(date) %>%
  summarise(tavg = mean(tavg_c, na.rm = TRUE), .groups = "drop")

daily_flux_wide <- daily_flux %>%
  select(date, Treatment, mean) %>%
  tidyr::pivot_wider(names_from = Treatment, values_from = mean) %>%
  mutate(delta_flux = `Sorghum + Rye` - Sorghum)

diag_df <- daily_flux_wide %>% left_join(daily_moist, by = "date") %>% left_join(daily_temp, by = "date")

p1 <- ggplot(diag_df, aes(delta_vwc, delta_flux)) +
  geom_hline(yintercept = 0, colour = "grey70") +
  geom_vline(xintercept = 0, colour = "grey70") +
  geom_point() + geom_smooth(method = "lm", se = TRUE) +
  theme_publication() +
  labs(x = "Δ VWC (S+R − S)", y = expression(Δ~N[2]*O~flux~(g~N~ha^-1~d^-1)))

p2 <- ggplot(diag_df, aes(tavg, delta_flux)) +
  geom_point() + geom_smooth(method = "lm", se = TRUE) +
  theme_publication() +
  labs(x = "Mean air temperature (°C)", y = expression(Δ~N[2]*O~flux))

p1 + p2
```

```{r flow-duration, message=FALSE, warning=FALSE}
#| label: fig-flow-duration
#| fig-cap: "Flow-duration curve by treatment (exceedance probability vs daily flow)."
#| fig-width: 9
#| fig-height: 5

fd <- leaching_data %>%
  filter(!is.na(flow_l)) %>%
  group_by(year, treatment) %>%
  arrange(desc(flow_l), .by_group = TRUE) %>%
  mutate(rank = row_number(),
         n = n(),
         prob_exceed = (rank - 0.5) / n) %>%
  ungroup()

ggplot(fd, aes(prob_exceed, flow_l, colour = treatment)) +
  geom_line() +
  scale_x_reverse(labels = scales::percent_format(accuracy = 1)) +
  scale_y_continuous(labels = scales::label_number(scale = 0.001, suffix = "k L")) +
  theme_publication() +
  labs(x = "Exceedance probability", y = "Daily tile flow (L)", colour = "Treatment")
```