---
title: "Sorghum-Rye Biomass and Flux Analysis"
author: "Jared Flater"
date: last-modified
format:
  html:
    theme: cosmo
    toc: true
    toc-location: left
    toc-depth: 3
    number-sections: true
    code-fold: true
    code-tools: true
    df-print: paged
    self-contained: true
    fig-width: 8
    fig-height: 6
execute:
  warning: false
  message: false
  echo: true
---

# Libraries

```{r setup, message=FALSE, warning=FALSE}
library(tidyverse)
library(readxl)
library(lubridate)
library(patchwork)
```

# Theme

```{r}
# Custom theme for consistency
theme_publication <- function(base_size = 12) {
  theme_minimal(base_size = base_size, base_family = "Arial") +
    theme(
      # Backgrounds
      panel.background = element_rect(fill = "#ffffffff", color = NA),
      plot.background = element_rect(fill = "#ffffffff", color = NA),
      strip.background = element_rect(fill = alpha("#A5CAD2", 0.2)),
      
      # Grid
      panel.grid.major = element_line(color = alpha("#B7B5B3", 0.2)),
      panel.grid.minor = element_blank(),
      panel.spacing = unit(2, "lines"),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1),

      # Text & Axis
      text = element_text(color = "#000000ff"),
      axis.text = element_text(color = "#000000ff", size = base_size * 0.8),
      axis.title = element_text(size = base_size),
      axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
      axis.line = element_line(color = "black", linewidth = 0.5),
      axis.ticks = element_line(color = "black", linewidth = 0.5),
      
      # Legend
      legend.position = "top",
      legend.justification = "center",
      legend.direction = "horizontal",
      legend.box = "horizontal",
      legend.margin = margin(b = 1, unit = "pt"),
      legend.box.margin = margin(b = 1, unit = "pt"),
      legend.text = element_text(size = base_size * 0.9),
      legend.title = element_text(size = base_size),
      legend.key.width = unit(0.8, "cm"),
      legend.key.height = unit(0.3, "cm")
    )
}

# Treatment colors
treatment_colors <- c(
  "Sorghum" = "#D8D97AFF",
  "Sorghum + Rye" = "#95C36EFF", 
  "Sorghum + WCC" = "#95C36EFF",
  "Corn" = "#74C8C3FF",
  "Soy" = "#0A2E57FF"
)

scale_color_treatments <- function() scale_color_manual(values = treatment_colors)
scale_fill_treatments <- function() scale_fill_manual(values = treatment_colors)
```

# Data loading

```{r}
rain <- read_xlsx("data/rain/historical_rain.xlsx")
gdd <- read_xlsx("data/rain/historical_rain.xlsx")
flux_data <- read_csv("data/cleaned_flux_data.csv") |>
  mutate(date = as.Date(date)) 


```

# Figure 1: Precipitation and GDD plots with historical envelopes

```{r}
# Precipitation and GDD plots with historical envelopes
# Import historical rain and gdd data

gdd <- gdd %>%
  select(day, doy, gdd_50_86) %>%
  mutate(
    date = as.Date(day),
    year = year(date),
  ) %>%
  group_by(year) %>%
  arrange(date) %>%
  mutate(cumulative_gdd = cumsum(gdd_50_86))

gdd <- gdd %>%
  mutate(doy_date = as.Date(doy - 1, origin = "2000-01-01"))

rain <- rain %>%
  select(day, doy, precipmm) %>%
  mutate(
    date = as.Date(day),
    year = year(date),
  ) %>%
  group_by(year) %>%
  arrange(date) %>%
  mutate(cumulative_precip = cumsum(precipmm))

rain <- rain %>%
  mutate(doy_date = as.Date(doy - 1, origin = "2000-01-01"))

# Calculate historical envelope for RAIN (excluding 2023 and 2024)
hist_env_rain <- rain |>
  filter(!(year %in% c(2023, 2024))) |>
  group_by(doy_date) |>
  summarize(
    min_cum = min(cumulative_precip, na.rm = TRUE),
    max_cum = max(cumulative_precip, na.rm = TRUE)
  )

# Calculate historical envelope for GDD (excluding 2023 and 2024)
hist_env_gdd <- gdd |>
  filter(!(year %in% c(2023, 2024))) |>
  group_by(doy_date) |>
  summarize(
    min_cum = min(cumulative_gdd, na.rm = TRUE),
    max_cum = max(cumulative_gdd, na.rm = TRUE)
  )

# Calculate historical mean for both rain and GDD
mean_cum_rain <- rain |>
  filter(!(year %in% c(2023, 2024))) |>
  group_by(doy_date) |>
  summarize(cumulative_precip = mean(cumulative_precip, na.rm = TRUE)) |>
  mutate(year = "Mean") |>
  filter(doy_date != "2000-12-31")

mean_cum_gdd <- gdd |>
  filter(!(year %in% c(2023, 2024))) |>
  group_by(doy_date) |>
  summarize(cumulative_gdd = mean(cumulative_gdd, na.rm = TRUE)) |>
  mutate(year = "Mean") |>
  filter(doy_date != "2000-12-31")

# Combine highlighted years with mean
rain_highlight <- rain |>
  filter(year %in% c(2023, 2024)) |>
  mutate(year = as.character(year)) |>
  bind_rows(mean_cum_rain)

gdd_highlight <- gdd |>
  filter(year %in% c(2023, 2024)) |>
  mutate(year = as.character(year)) |>
  bind_rows(mean_cum_gdd)

# Rain plot
rain_plot_v2 <- ggplot() +
  geom_ribbon(
    data = hist_env_rain,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  geom_line(
    data = rain_highlight,
    aes(x = doy_date, y = cumulative_precip, color = year, linetype = year),
    linewidth = 0.6
  ) +
  scale_color_manual(
    name = "Year",
    values = c("2023" = "#E41A1C", "2024" = "#377EB8", "Mean" = "black"),
    labels = c("2023" = "2023", "2024" = "2024", "Mean" = "Mean (Historical)")
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c("2023" = "solid", "2024" = "dashed", "Mean" = "dotdash"),
    labels = c("2023" = "2023", "2024" = "2024", "Mean" = "Mean (Historical)")
  ) +
  scale_x_date(date_breaks = "2 months", date_labels = "%b") +
  labs(x = "", y = "Cumulative Precipitation (mm)") +
  theme_publication(base_size = 10)

# GDD plot
gdd_plot_v2 <- ggplot() +
  geom_ribbon(
    data = hist_env_gdd,
    aes(x = doy_date, ymin = min_cum, ymax = max_cum),
    fill = "gray80", alpha = 0.6
  ) +
  geom_line(
    data = gdd_highlight,
    aes(x = doy_date, y = cumulative_gdd, color = year, linetype = year),
    linewidth = 0.6
  ) +
  scale_color_manual(
    name = "Year",
    values = c("2023" = "#E41A1C", "2024" = "#377EB8", "Mean" = "black"),
    labels = c("2023" = "2023", "2024" = "2024", "Mean" = "Mean (Historical)")
  ) +
  scale_linetype_manual(
    name = "Year",
    values = c("2023" = "solid", "2024" = "dashed", "Mean" = "dotdash"),
    labels = c("2023" = "2023", "2024" = "2024", "Mean" = "Mean (Historical)")
  ) +
  scale_x_date(date_breaks = "2 months", date_labels = "%b") +
  labs(x = "", y = "Cumulative Growing Degree Days (GDD)") +
  theme_publication(base_size = 10)

# Combine into pdplot with shared legend
six_panel_plot <- (rain_plot_v2 | gdd_plot_v2) +
  plot_layout(guides = "collect") &
  theme_publication(base_size = 10) &
  theme(
    legend.position = "top",
    plot.margin = margin(t = 3, r = 4, b = 2, l = 4, unit = "pt")
  ) &
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),
    linetype = guide_legend(nrow = 2, byrow = TRUE)
  )

ggsave("figures/figure1_weather.png", six_panel_plot, 
       width = 84, height = 105, dpi = 600, bg = "white", units = "mm")
six_panel_plot

# Report date ranges used for historical means (excludes 2023, 2024)
hist_range_rain <- rain |>
  filter(!(year %in% c(2023, 2024))) |>
  ungroup() |>
  summarize(
    start_date = min(year, na.rm = TRUE),
    end_date   = max(year, na.rm = TRUE)
  )

hist_range_gdd <- gdd |>
  filter(!(year %in% c(2023, 2024))) |>
  ungroup() |>
  summarize(
    start_date = min(year, na.rm = TRUE),
    end_date   = max(year, na.rm = TRUE)
  )

cat("Historical mean period (rain):", hist_range_rain$start_date, "to", hist_range_rain$end_date, "\n")
cat("Historical mean period (GDD):",  hist_range_gdd$start_date, "to", hist_range_gdd$end_date, "\n")
```

# Figure 2: Soil moisture and temperature from LiCOR survey chamber

```{r}
# Soil moisture and temperature 4-panel plot

# Calculate summary statistics
moist_temp <- flux_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  mutate(Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment)) |>
  group_by(Treatment, year, date) |>
  summarise(
    mean_soil_moisture = mean(swc_2_mean, na.rm = TRUE),
    mean_soil_temp = mean(ts_2_mean, na.rm = TRUE),
    .groups = "drop"
  )

# Per-date t-tests between treatments
raw_soil <- flux_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  mutate(
    Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment),
    year = year(date)
  )

get_date_pvals <- function(df, value_col) {
  df |>
    group_by(year, date) |>
    summarise(
      p = {
        vals <- .data[[value_col]]
        trt  <- Treatment
        has_two <- length(unique(na.omit(trt))) == 2
        counts  <- table(trt[!is.na(vals)])
        ok <- has_two && all(counts >= 1) && length(na.omit(vals)) >= 2
        if (ok) {
          out <- tryCatch(t.test(vals ~ trt)$p.value, error = function(e) NA_real_)
          out
        } else NA_real_
      },
      .groups = "drop"
    ) |>
    filter(!is.na(p) & p < 0.05)
}

pvals_moist <- get_date_pvals(raw_soil, "swc_2_mean")
pvals_temp  <- get_date_pvals(raw_soil, "ts_2_mean")

# Split data by year
moist_temp_2023 <- filter(moist_temp, year == 2023)
moist_temp_2024 <- filter(moist_temp, year == 2024)

# Calculate global y-axis limits
global_moisture_limits <- range(moist_temp$mean_soil_moisture, na.rm = TRUE)
global_temp_limits <- range(moist_temp$mean_soil_temp, na.rm = TRUE)

global_moisture_limits[2] <- global_moisture_limits[2] * 1.12
global_temp_limits[2] <- 40

moisture_breaks <- pretty(global_moisture_limits, n = 5)
temp_breaks <- pretty(global_temp_limits, n = 5)

# Star positions for moisture
moisture_stars <- moist_temp |>
  group_by(year, date) |>
  summarise(y_star = max(mean_soil_moisture, na.rm = TRUE) * 1.05, .groups = "drop") |>
  inner_join(pvals_moist, by = c("year", "date")) |>
  filter(is.finite(y_star))

moisture_segments <- moisture_stars |>
  distinct(year, date) |>
  left_join(moist_temp, by = c("year", "date")) |>
  group_by(year, date) |>
  slice_max(order_by = mean_soil_moisture, n = 1, with_ties = FALSE) |>
  mutate(
    x = date - 2,
    xend = date + 2,
    y = 0.5
  ) |>
  ungroup()

# Star positions for temperature
temp_stars <- moist_temp |>
  group_by(year, date) |>
  summarise(y_star = max(mean_soil_temp, na.rm = TRUE) * 1.05, .groups = "drop") |>
  inner_join(pvals_temp, by = c("year", "date")) |>
  filter(is.finite(y_star))

temp_segments <- temp_stars |>
  distinct(year, date) |>
  left_join(moist_temp, by = c("year", "date")) |>
  group_by(year, date) |>
  slice_max(order_by = mean_soil_temp, n = 1, with_ties = FALSE) |>
  mutate(
    x = date - 2,
    xend = date + 2,
    y = 40 
  ) |>
  ungroup()

# 2023 Soil Moisture (bottom left)
p1 <- ggplot(moist_temp_2023, aes(x = date, y = mean_soil_moisture, color = Treatment, linetype = Treatment, shape = Treatment)) +
  geom_line(linewidth = 0.6) +
  geom_point(size = 1.5) +
  scale_color_manual(values = treatment_colors) +
  scale_linetype_manual(values = c("Sorghum" = "dashed", "Sorghum + WCC" = "solid")) +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + WCC" = 15)) +
  scale_x_date(date_breaks = "2 months", date_labels = "%b",
               limits = c(as.Date("2023-01-01"), as.Date("2023-12-31"))) +
  scale_y_continuous(limits = global_moisture_limits, breaks = moisture_breaks, 
                     expand = expansion(mult = c(0.02, 0.02))) +
  labs(x = "Month", y = expression("Volumetric Soil Moisture (cm"^3*" "*"cm"^-3*")"),
       color = "Treatment", linetype = "Treatment", shape = "Treatment") +
  geom_hline(yintercept = 0.5, color = "black", linewidth = 7) +
  geom_segment(
    data = moisture_segments |> filter(year == 2023),
    aes(x = x, xend = xend, y = y, yend = y, color = Treatment),
    linewidth = 7, inherit.aes = FALSE, show.legend = FALSE
  ) +
  annotate("text", x = as.Date("2023-01-15"), y = 0.47,
           label = "c", size = 4, color = "black", fontface = "bold") +
  theme_publication(base_size = 10) +
  theme(legend.position = "none")

# 2024 Soil Moisture (bottom right)
p2 <- ggplot(moist_temp_2024, aes(x = date, y = mean_soil_moisture, color = Treatment, linetype = Treatment, shape = Treatment)) +
  geom_line(linewidth = 0.6) +
  geom_point(size = 1.5) +
  scale_color_manual(values = treatment_colors) +
  scale_linetype_manual(values = c("Sorghum" = "dashed", "Sorghum + WCC" = "solid")) +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + WCC" = 15)) +
  scale_x_date(date_breaks = "2 months", date_labels = "%b",
               limits = c(as.Date("2024-01-01"), as.Date("2024-12-31"))) +
  scale_y_continuous(limits = global_moisture_limits, breaks = moisture_breaks,
                     expand = expansion(mult = c(0.02, 0.02))) +
  labs(x = "Month", y = "", color = "Treatment", linetype = "Treatment", shape = "Treatment") +
  geom_hline(yintercept = 0.5, color = "black", linewidth = 7) +
  geom_segment(
    data = moisture_segments |> filter(year == 2024),
    aes(x = x, xend = xend, y = y, yend = y, color = Treatment),
    linewidth = 7, inherit.aes = FALSE, show.legend = FALSE
  ) +
  annotate("text", x = as.Date("2024-01-15"), y = 0.47,
           label = "d", size = 4, color = "black", fontface = "bold") +
  theme_publication(base_size = 10) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line.y = element_blank(),
    legend.position = "none"
  )

# 2023 Soil Temperature (top left)
p3 <- ggplot(moist_temp_2023, aes(x = date, y = mean_soil_temp, color = Treatment, linetype = Treatment, shape = Treatment)) +
  geom_line(linewidth = 0.6) +
  geom_point(size = 1.5) +
  scale_color_manual(values = treatment_colors) +
  scale_linetype_manual(values = c("Sorghum" = "dashed", "Sorghum + WCC" = "solid")) +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + WCC" = 15)) +
  scale_x_date(date_breaks = "2 months", date_labels = "%b",
               limits = c(as.Date("2023-01-01"), as.Date("2023-12-31"))) +
  scale_y_continuous(limits = global_temp_limits, breaks = temp_breaks,
                     expand = expansion(mult = c(0.05, 0.05))) +
  labs(x = "", y = "Soil Temperature (°C)", color = "Treatment", linetype = "Treatment", shape = "Treatment") +
  geom_hline(yintercept = 40, color = "black", linewidth = 7) +
  geom_segment(
    data = temp_segments |> filter(year == 2023),
    aes(x = x, xend = xend, y = y, yend = y, color = Treatment),
    linewidth = 7, inherit.aes = FALSE, show.legend = FALSE
  ) +
  annotate("text", x = as.Date("2023-01-15"), y = 37,
           label = "a", size = 4, color = "black", fontface = "bold") +
  theme_publication(base_size = 10) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.line.x = element_blank(),
    legend.position = "none"
  )

# 2024 Soil Temperature (top right)
p4 <- ggplot(moist_temp_2024, aes(x = date, y = mean_soil_temp, color = Treatment, linetype = Treatment, shape = Treatment)) +
  geom_line(linewidth = 0.6) +
  geom_point(size = 1.5) +
  scale_color_manual(values = treatment_colors) +
  scale_linetype_manual(values = c("Sorghum" = "dashed", "Sorghum + WCC" = "solid")) +
  scale_shape_manual(values = c("Sorghum" = 16, "Sorghum + WCC" = 15)) +
  scale_x_date(date_breaks = "2 months", date_labels = "%b",
               limits = c(as.Date("2024-01-01"), as.Date("2024-12-31"))) +
  scale_y_continuous(limits = global_temp_limits, breaks = temp_breaks,
                     expand = expansion(mult = c(0.05, 0.05))) +
  labs(x = "", y = "", color = "Treatment", linetype = "Treatment", shape = "Treatment") +
  geom_hline(yintercept = 40, color = "black", linewidth = 7) +
  geom_segment(
    data = temp_segments |> filter(year == 2024),
    aes(x = x, xend = xend, y = y, yend = y, color = Treatment),
    linewidth = 7, inherit.aes = FALSE, show.legend = FALSE
  ) +
  annotate("text", x = as.Date("2024-01-15"), y = 37,
           label = "b", size = 4, color = "black", fontface = "bold") +
  theme_publication(base_size = 10) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line = element_blank(),
    legend.position = "none"
  )

# Combine panels
soil_4panel <- (p3 | p4) / (p1 | p2) +
  patchwork::plot_layout(guides = "collect", heights = c(1, 1)) &
  theme(legend.position = "top") &
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),
    linetype = guide_legend(nrow = 2, byrow = TRUE),
    shape = guide_legend(nrow = 2, byrow = TRUE)
  )

soil_4panel
# Print the range in soil temperature and moisture
cat("Soil Moisture Range:", round(global_moisture_limits[1], 3), "to", round(global_moisture_limits[2], 3), "cm3 cm-3\n")
cat("Soil Temperature Range:", round(global_temp_limits[1], 2), "to", round(global_temp_limits[2], 2), "°C\n")
ggsave("figures/figure2_soil_moisture_temperature.png", soil_4panel, 
       width = 174, height = 174, dpi = 600, bg = "white", units = "mm")
```

```{r}
# ---- Extract + summarize SIGNIFICANT date-level treatment differences (Figure 2) ----

dir.create("data/processed", recursive = TRUE, showWarnings = FALSE)

# Helper: build wide table and join p-values
make_sig_table <- function(means_df, value_col, pvals_df, out_csv,
                           sorghum_name = "Sorghum",
                           wcc_name = "Sorghum + WCC") {

  wide <- means_df |>
    select(year, date, Treatment, !!sym(value_col)) |>
    tidyr::pivot_wider(names_from = Treatment, values_from = !!sym(value_col)) |>
    rename(
      sorghum = !!sorghum_name,
      wcc     = !!wcc_name
    ) |>
    mutate(
      diff_sorghum_minus_wcc = sorghum - wcc
    ) |>
    filter(!is.na(sorghum) & !is.na(wcc))

  sig_tbl <- wide |>
    left_join(pvals_df, by = c("year", "date")) |>
    mutate(
      p = as.numeric(p),
      sig = !is.na(p) & p < 0.05,
      wcc_lower = wcc < sorghum,
      sig_wcc_lower = sig & wcc_lower
    )

  readr::write_csv(sig_tbl, out_csv)
  sig_tbl
}

# Temperature table (uses moist_temp means + pvals_temp from your t-tests)
temp_sig_table <- make_sig_table(
  means_df = moist_temp,
  value_col = "mean_soil_temp",
  pvals_df = pvals_temp,
  out_csv = "data/processed/soil_temp_sig_by_date.csv"
)

# Moisture table
moist_sig_table <- make_sig_table(
  means_df = moist_temp,
  value_col = "mean_soil_moisture",
  pvals_df = pvals_moist,
  out_csv = "data/processed/soil_moist_sig_by_date.csv"
)

# ---- Summaries needed for manuscript text ----

summarize_sig <- function(sig_tbl) {
  # X out of Y where significant differences exist (either direction)
  Y <- sum(sig_tbl$sig, na.rm = TRUE)
  X <- sum(sig_tbl$sig_wcc_lower, na.rm = TRUE)

  by_year <- sig_tbl |>
    group_by(year) |>
    summarise(
      Y = sum(sig, na.rm = TRUE),
      X = sum(sig_wcc_lower, na.rm = TRUE),
      .groups = "drop"
    )

  # Range of sorghum minus wcc differences on significant-lower dates
  diff_rng <- sig_tbl |>
    filter(sig_wcc_lower) |>
    summarise(
      min_diff = min(diff_sorghum_minus_wcc, na.rm = TRUE),
      max_diff = max(diff_sorghum_minus_wcc, na.rm = TRUE)
    )

  list(X = X, Y = Y, by_year = by_year, diff_rng = diff_rng)
}

temp_sum  <- summarize_sig(temp_sig_table)
moist_sum <- summarize_sig(moist_sig_table)

# Print strings you can copy into manuscript drafts
cat(
  "Temperature: WCC significantly LOWER than Sorghum on ",
  temp_sum$X, " out of ", temp_sum$Y,
  " significant dates (",
  paste0(temp_sum$by_year$year, ": ", temp_sum$by_year$X, "/", temp_sum$by_year$Y, collapse = ", "),
  "). Sorghum was ",
  round(temp_sum$diff_rng$min_diff, 2), "–", round(temp_sum$diff_rng$max_diff, 2),
  " °C warmer on those dates (p < 0.05).\n",
  sep = ""
)

cat(
  "Moisture: WCC significantly LOWER than Sorghum on ",
  moist_sum$X, " out of ", moist_sum$Y,
  " significant dates (",
  paste0(moist_sum$by_year$year, ": ", moist_sum$by_year$X, "/", moist_sum$by_year$Y, collapse = ", "),
  "). Sorghum was ",
  round(moist_sum$diff_rng$min_diff, 3), "–", round(moist_sum$diff_rng$max_diff, 3),
  " cm3 cm-3 higher on those dates (p < 0.05).\n",
  sep = ""
)

cat("Saved: data/processed/soil_temp_sig_by_date.csv\n")
cat("Saved: data/processed/soil_moist_sig_by_date.csv\n")

```

# Figure 3: Sorghum and Sorghum + WCC biomass

```{r}

```

# Figure 4: Mean daily and cummulative nitrous oxide emissions

```{r}
# Prepare Flux Data
flux_subset <- flux_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  mutate(
    Treatment = if_else(
      treatment == "Sorghum + Rye",
      "Sorghum + WCC",
      treatment
    ),
    year = year(date)
  ) |>
  filter(year %in% c(2023, 2024))

# 1. Daily Means and SE (for top panel)
daily_flux <- flux_subset |>
  group_by(Treatment, year, date) |>
  summarise(
    mean_flux = mean(gnha_day_no_negative, na.rm = TRUE) / 1000, # kg N ha-1 day-1
    se_flux = sd(gnha_day_no_negative, na.rm = TRUE) /
      sqrt(sum(!is.na(gnha_day_no_negative))) /
      1000,
    .groups = "drop"
  )

# 2. Significance (Wilcoxon on plot means)
daily_significance <- flux_subset |>
  group_by(year, date, Treatment, plot) |>
  summarise(
    plot_mean_flux = mean(gnha_day_no_negative, na.rm = TRUE),
    .groups = "drop"
  ) |>
  group_by(year, date) |>
  summarise(
    p_value = {
      sorghum_vals <- plot_mean_flux[Treatment == "Sorghum"]
      wcc_vals <- plot_mean_flux[Treatment == "Sorghum + WCC"]
      sorghum_vals <- sorghum_vals[!is.na(sorghum_vals)]
      wcc_vals <- wcc_vals[!is.na(wcc_vals)]

      if (length(sorghum_vals) >= 3 && length(wcc_vals) >= 3) {
        tryCatch(
          wilcox.test(sorghum_vals, wcc_vals, exact = FALSE)$p.value,
          error = function(e) NA_real_
        )
      } else {
        NA_real_
      }
    },
    .groups = "drop"
  ) |>
  mutate(
    significant = p_value < 0.05,
    star_label = if_else(significant & !is.na(p_value), "*", "")
  )

# Star positions
max_flux_by_date <- daily_flux |>
  group_by(year, date) |>
  summarise(max_flux = max(mean_flux + se_flux, na.rm = TRUE), .groups = "drop")

star_data <- daily_significance |>
  left_join(max_flux_by_date, by = c("year", "date")) |>
  filter(star_label == "*") |>
  mutate(star_y = max_flux * 1.1)

# 3. Cumulative Flux Calculation (CORRECTED)

# First: Aggregate to one value per plot per day (averaging Row/Interrow)
daily_flux_plot_level <- flux_subset |>
  group_by(Treatment, year, plot, date) |>
  summarise(
    daily_flux = mean(gnha_day_no_negative, na.rm = TRUE) / 1000, # kg N
    .groups = "drop"
  )

# Second: Interpolate and Accumulate
cum_flux_plot_level <- daily_flux_plot_level |>
  arrange(Treatment, year, plot, date) |>
  group_by(Treatment, year, plot) |>
  group_modify(~ {
    # Complete the date sequence for this specific plot
    df <- .x |>
      complete(date = seq(min(date), max(date), by = "day")) |>
      arrange(date)

    non_na <- !is.na(df$daily_flux)
    
    # Skip if insufficient data
    if (sum(non_na) == 0) return(tibble())

    # Interpolate
    flux_interp <- if (sum(non_na) >= 2) {
      approx(
        x = df$date[non_na],
        y = df$daily_flux[non_na],
        xout = df$date,
        rule = 1, # NA outside range
        ties = "ordered"
      )$y
    } else {
      # Fallback for single point (rare)
      rep(df$daily_flux[non_na][1], nrow(df))
    }

    # Accumulate and filter out NAs (e.g. before first sampling)
    df |>
      mutate(
        flux_interp = flux_interp,
        cum_flux = cumsum(flux_interp)
      ) |>
      filter(!is.na(flux_interp))
  }) |>
  ungroup()

# Third: Summary Statistics for Plotting
cum_flux_summary <- cum_flux_plot_level |>
  group_by(Treatment, year, date) |>
  summarise(
    cum_flux_mean = mean(cum_flux, na.rm = TRUE),
    cum_flux_sd = sd(cum_flux, na.rm = TRUE),
    n_plots = n(),
    cum_flux_se = cum_flux_sd / sqrt(n_plots),
    t_crit = if_else(n_plots > 1, qt(0.975, df = n_plots - 1), NA_real_),
    cum_flux_ci = t_crit * cum_flux_se,
    .groups = "drop"
  )

# Precipitation
flux_date_ranges <- daily_flux |>
  group_by(year) |>
  summarise(min_date = min(date), max_date = max(date), .groups = "drop")
daily_precip_trimmed <- rain |>
  select(date, year, precipmm) |>
  filter(year %in% c(2023, 2024)) |>
  left_join(flux_date_ranges, by = "year") |>
  filter(date >= min_date, date <= max_date)
fert_events <- tibble(
  year = c(2023, 2024),
  fertilizer_date = as.Date(c("2023-05-05", "2024-07-17"))
)

# Plotting Constants
global_max_flux <- max(daily_flux$mean_flux + daily_flux$se_flux, na.rm = TRUE)
global_max_precip <- max(daily_precip_trimmed$precipmm, na.rm = TRUE)
global_max_cum_flux <- max(
  cum_flux_summary$cum_flux_mean + cum_flux_summary$cum_flux_ci,
  na.rm = TRUE
)
global_precip_scale_factor <- global_max_flux * 0.4 / global_max_precip
global_plot_top <- global_max_flux * 1.1

# Plot Function
create_dual_axis_plot <- function(year_val, is_right_panel = FALSE) {
  flux_year <- filter(daily_flux, year == year_val)
  precip_year <- filter(daily_precip_trimmed, year == year_val)
  star_year <- filter(star_data, year == year_val)
  fert_year <- filter(fert_events, year == year_val)
  cum_flux_year <- filter(cum_flux_summary, year == year_val)
  year_start <- as.Date(paste0(year_val, "-01-01"))
  year_end <- as.Date(paste0(year_val, "-12-31"))

  daily_plot <- ggplot() +
    geom_rect(
      data = precip_year,
      aes(
        xmin = date - 0.5,
        xmax = date + 0.5,
        ymin = global_plot_top - precipmm * global_precip_scale_factor,
        ymax = global_plot_top
      ),
      fill = "#377EB8",
      alpha = 0.7
    ) +
    geom_point(
      data = flux_year,
      aes(x = date, y = mean_flux, color = Treatment),
      size = 1.5
    ) +
    geom_errorbar(
      data = flux_year,
      aes(
        x = date,
        ymin = mean_flux - se_flux,
        ymax = mean_flux + se_flux,
        color = Treatment
      ),
      width = 0.2,
      alpha = 0.5
    ) +
    geom_vline(
      data = fert_year,
      aes(xintercept = fertilizer_date),
      linetype = "dashed",
      color = "black",
      alpha = 0.7
    ) +
    geom_text(
      data = star_year,
      aes(x = date, y = star_y, label = star_label),
      color = "black",
      size = 5
    ) +
    guides(color = "none") +
    scale_color_manual(values = treatment_colors) +
    scale_x_date(
      date_breaks = "2 months",
      date_labels = "%b",
      limits = c(year_start, year_end)
    ) +
    scale_y_continuous(
      name = if (!is_right_panel) {
        expression("Daily N"[2] * "O Flux (kg N ha"^-1 * " d"^-1 * ")")
      } else {
        ""
      },
      limits = c(0, global_plot_top),
      sec.axis = sec_axis(
        ~ (global_plot_top - .) / global_precip_scale_factor,
        name = if (is_right_panel) "Daily Precipitation (mm)" else ""
      )
    ) +
    theme_publication(base_size = 10) +
    theme(
      legend.position = "none",
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.line.x = element_blank(),
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.line.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text(),
      axis.text.y.right = if (is_right_panel) {
        element_text(color = "#377EB8")
      } else {
        element_blank()
      },
      axis.ticks.y.right = if (is_right_panel) {
        element_line()
      } else {
        element_blank()
      },
      axis.title.y.right = if (is_right_panel) {
        element_text(color = "#377EB8")
      } else {
        element_blank()
      }
    ) +
    labs(x = "") +
    geom_hline(yintercept = 0, linetype = "solid", alpha = 0.3)

  cumulative_plot <- ggplot(
    cum_flux_year,
    aes(x = date, y = cum_flux_mean, color = Treatment, fill = Treatment)
  ) +
    geom_ribbon(
      aes(
        ymin = pmax(cum_flux_mean - cum_flux_ci, 0),
        ymax = cum_flux_mean + cum_flux_ci
      ),
      alpha = 0.15,
      linewidth = 0
    ) +
    geom_line(linewidth = 1) +
    geom_vline(
      data = fert_year,
      aes(xintercept = fertilizer_date),
      linetype = "dashed",
      color = "black",
      alpha = 0.7
    ) +
    scale_color_manual(values = treatment_colors) +
    scale_fill_manual(values = treatment_colors) +
    scale_x_date(
      date_breaks = "2 months",
      date_labels = "%b",
      limits = c(year_start, year_end)
    ) +
    scale_y_continuous(
      name = if (!is_right_panel) {
        expression("Cumulative N"[2] * "O Flux (kg N ha"^-1 * ")")
      } else {
        ""
      },
      limits = c(0, global_max_cum_flux)
    ) +
    labs(x = "Month") +
    theme_publication(base_size = 10) +
    theme(
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.line.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text()
    )

  (daily_plot / cumulative_plot) + patchwork::plot_layout(heights = c(1.2, 1))
}

figure3_dual_axis <- (create_dual_axis_plot(2023) |
  create_dual_axis_plot(2024, TRUE)) +
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position = "top", legend.justification = "center")

figure3_dual_axis

ggsave(
  filename = "figures/figure2_flux_precip_cumulative_2023_2024_plotlevelCI_dualaxis.png",
  plot = figure3_dual_axis,
  width = 174,
  height = 174,
  units = "mm",
  dpi = 600,
  bg = "white"
)
```

# plot-level cumulative range accross all sorghum sorghum + WCC and corn for the 2 years

```{r}
# Filter data for Sorghum, Sorghum + WCC, and Corn across 2023 and 2024
flux_range_data <- flux_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye", "Corn")) |>
  mutate(
    Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment),
    year = year(date)
  ) |>
  filter(year %in% c(2023, 2024))

# Calculate daily flux per plot (averaging row/interrow if present)
daily_flux_plot <- flux_range_data |>
  group_by(Treatment, year, plot, date) |>
  summarise(
    daily_flux = mean(gnha_day_no_negative, na.rm = TRUE) / 1000, # kg N ha-1
    .groups = "drop"
  )

# Extract the Range in GRAMS 
range_stats <- daily_flux_plot |>
  summarise(
    min_flux_g = min(daily_flux), 
    max_flux_g = max(daily_flux)
  )

# 3. Check specific High Values (to verify the ">600" claim)
top_fluxes <- daily_flux_plot |>
  arrange(desc(daily_flux)) |>
  slice(1:5) |>
  select(year, Treatment, date, daily_flux)

# Print results
print(range_stats)
print("Top 5 Flux Events (g N ha-1 d-1):")
print(top_fluxes)

# Interpolate daily values and calculate cumulative sum for each plot
cum_flux_plot <- daily_flux_plot |>
  arrange(Treatment, year, plot, date) |>
  group_by(Treatment, year, plot) |>
  group_modify(~ {
    # Create full date sequence for the plot's observation period
    df <- .x |>
      complete(date = seq(min(date), max(date), by = "day")) |>
      arrange(date)

    non_na <- !is.na(df$daily_flux)
    if (sum(non_na) == 0) return(tibble())

    # Linear interpolation
    flux_interp <- if (sum(non_na) >= 2) {
      approx(
        x = df$date[non_na],
        y = df$daily_flux[non_na],
        xout = df$date,
        rule = 1, # NA outside observed range
        ties = "ordered"
      )$y
    } else {
      rep(df$daily_flux[non_na][1], nrow(df))
    }

    df |>
      mutate(
        flux_interp = flux_interp,
        cum_flux = cumsum(replace_na(flux_interp, 0))
      ) |>
      filter(!is.na(flux_interp))
  }) |>
  ungroup()

# Extract the final cumulative total for each plot
final_cum_values <- cum_flux_plot |>
  group_by(Treatment, year, plot) |>
  summarise(total_cum = max(cum_flux), .groups = "drop")

# Calculate and print the range across all plots
overall_range <- range(final_cum_values$total_cum)
cat("Overall cumulative N2O flux range (kg N ha-1) across Sorghum, Sorghum + WCC, and Corn (2023-2024):",
    paste(round(overall_range, 2), collapse = " - "), "\n")
```

```{r}
library(dplyr)
library(gt)

# 1. Use your existing 'cum_flux_summary' (which already has Means & CIs)
# Filter for just the relevant treatments (No Corn) and the final date of each year
validation_stats <- cum_flux_summary |>
  filter(Treatment %in% c("Sorghum", "Sorghum + WCC")) |>
  group_by(year, Treatment) |>
  slice_max(date, n = 1) |> # Get the end-of-season cumulative total
  ungroup() |>
  select(year, Treatment, cum_flux_mean, cum_flux_se, cum_flux_ci)

# 2. Create the Publication-Ready Table
validation_table <- validation_stats |>
  mutate(
    # Create the "Mean (SE)" string often used in papers
    Mean_SE = sprintf("%.2f (%.2f)", cum_flux_mean, cum_flux_se),
    # Calculate 95% CI Range
    CI_Lower = cum_flux_mean - cum_flux_ci,
    CI_Upper = cum_flux_mean + cum_flux_ci,
    # Create a visual check for the "0.9 to 1.6" range statement
    In_Range_Check = case_when(
      cum_flux_mean >= 0.9 & cum_flux_mean <= 1.6 ~ "✅ Matches Text",
      TRUE ~ "⚠️ Check Value"
    )
  ) |>
  select(year, Treatment, Mean_SE, CI_Lower, CI_Upper, In_Range_Check) |>
  gt() |>
  tab_header(
    title = md("**Validation of Cumulative N₂O Statement**"),
    subtitle = "Verifying: 'Reduced non-significantly (Range: 0.9 to 1.6 kg N)'"
  ) |>
  cols_label(
    Mean_SE = "Mean Cumulative Flux (SE)",
    CI_Lower = "95% CI Lower",
    CI_Upper = "95% CI Upper",
    In_Range_Check = "Text Validation"
  ) |>
  fmt_number(
    columns = c(CI_Lower, CI_Upper),
    decimals = 2
  ) |>
  # Color code the rows to make it easy to spot the treatments
  tab_style(
    style = list(cell_fill(color = "#f9f9f9")),
    locations = cells_body(rows = year == 2024)
  )

# 3. Display and Save
validation_table

# Save it so you have a permanent record for the response letter
gtsave(validation_table, "figures/validation_table_cumulative_n2o.png")
```

# Row vs. Interrow flux comparisons

```{r}
glimpse(flux_data)

library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)

# 1. Prepare Data & Fix Labels
# We factorize 'Treatment' immediately to lock in the "Sorghum + WCC" label order
row_interrow_comparison <- flux_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  mutate(
    Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment),
    Treatment = factor(Treatment, levels = c("Sorghum", "Sorghum + WCC")), # Locks order
    year = year(date)
  ) |>
  filter(year %in% c(2023, 2024)) |>
  select(year, date, Treatment, plot, rowvs_interrow, gnha_day_no_negative)

# 2. Summary Statistics (Your Request)
row_interrow_summary <- row_interrow_comparison |>
  group_by(year, Treatment, rowvs_interrow) |> # Grouped by Year/Trt/Pos
  summarise(
    mean_flux = mean(gnha_day_no_negative, na.rm = TRUE),
    max_flux = max(gnha_day_no_negative, na.rm = TRUE),
    sd = sd(gnha_day_no_negative, na.rm = TRUE),
    n = sum(!is.na(gnha_day_no_negative)),
    .groups = "drop"
  )

print("--- Summary Statistics by Position ---")
print(row_interrow_summary)

# 3. Calculate Differences for Reviewer MM2 (Interrow - Row)
# This pivots the data wide so we can subtract Row from Interrow for every specific plot/date
diff_analysis <- row_interrow_comparison |>
  pivot_wider(
    names_from = rowvs_interrow,
    values_from = gnha_day_no_negative,
    names_prefix = "Flux_"
  ) |>
  # Adjust 'Flux_Interrow' / 'Flux_Row' if your actual values in 'rowvs_interrow' differ (e.g. "Row", "Inter")
  mutate(
    Diff = Flux_Interrow - Flux_Row
  ) |>
  filter(!is.na(Diff))

# Statistical Test: Is the mean difference significantly different from 0?
t_test_result <- t.test(diff_analysis$Diff)

print("--- Paired T-Test Results (Reviewer Check) ---")
print(t_test_result)

# 4. PLOT A: Absolute Fluxes (Your Request)
p1_boxplot <- ggplot(row_interrow_comparison, aes(x = Treatment, y = gnha_day_no_negative, fill = rowvs_interrow)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) + # Hide outliers to see the box better
  geom_jitter(position = position_jitterdodge(), alpha = 0.1, size = 0.5) + # Show raw data points
  facet_wrap(~ year) +
  labs(
    title = "N2O Flux Distribution: Row vs. Interrow",
    y = expression("N"[2]*"O Flux (g N ha"^-1*" day"^-1*")"),
    fill = "Position"
  ) +
  scale_fill_manual(values = c("grey40", "grey80")) + # High contrast for paper
  theme_publication() +
  theme(legend.position = "top")

# 5. PLOT B: The "Difference" Plot (For Reviewer MM2)
# This shows if the Interrow is consistently higher (above 0) or lower (below 0)
p2_diff <- ggplot(diff_analysis, aes(x = Treatment, y = Diff, fill = Treatment)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  geom_violin(alpha = 0.5) +
  geom_boxplot(width = 0.1, outlier.shape = NA) +
  facet_wrap(~ year) +
  labs(
    title = "Systematic Bias Check: (Interrow - Row)",
    subtitle = "Centered on 0 (red line) justifies pooling data",
    y = expression("Difference (g N ha"^-1*" day"^-1*")")
  ) +
  scale_fill_manual(values = treatment_colors) +
  theme_publication() +
  theme(legend.position = "none")

# Display Plots
print(p1_boxplot)
print(p2_diff)


# Generate Descriptive Stats for All Treatments
flux_summary_stats <- flux_data |>
  # Ensure we capture ALL treatments (remove the filter if Miscanthus is in the raw data)
  filter(treatment %in% c("Sorghum", "Sorghum + Rye", "Corn", "Soy")) |> 
  mutate(
    Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment),
    year = year(date)
  ) |>
  filter(year %in% c(2023, 2024)) |>
  group_by(Treatment) |>
  summarise(
    min_flux = min(gnha_day_no_negative, na.rm = TRUE),
    max_flux = max(gnha_day_no_negative, na.rm = TRUE),
    mean_flux = mean(gnha_day_no_negative, na.rm = TRUE),
    median_flux = median(gnha_day_no_negative, na.rm = TRUE),
    n_obs = n()
  )

print(flux_summary_stats)
```

# Figure X: Nitrogen Leaching

```{r}
# Figure 5: Nitrate Leaching and Precipitation


# 1. Load and Process Leaching Data
# Define plot area constants
plot_area_ft2 <- 120 * 160
plot_area_ha <- plot_area_ft2 / 107639.1041671

leaching_data <- read_csv("data/clean_leaching.csv") |>
  janitor::clean_names() |>
  mutate(
    date = as.Date(date),
    year = year(date)
  ) |>
  filter(year %in% c(2023, 2024))

# 2. Daily Leaching Calculation
daily_leaching_summary <- leaching_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  mutate(
    Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment),
    daily_n_loss_kgha = (total_n_loss_mg / 1e6) / plot_area_ha
  ) |>
  group_by(Treatment, year, date) |>
  summarise(
    mean_loss = mean(daily_n_loss_kgha, na.rm = TRUE),
    se_loss = sd(daily_n_loss_kgha, na.rm = TRUE) / sqrt(sum(!is.na(daily_n_loss_kgha))),
    .groups = "drop"
  )

# 3. Cumulative Leaching Calculation
cum_leaching_summary <- leaching_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  mutate(
    Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment),
    cum_loss_kgha = (cumulative_n_loss_mg / 1e6) / plot_area_ha
  ) |>
  group_by(Treatment, year, date) |>
  summarise(
    cum_loss_mean = mean(cum_loss_kgha, na.rm = TRUE),
    cum_loss_sd = sd(cum_loss_kgha, na.rm = TRUE),
    n = n(),
    cum_loss_se = cum_loss_sd / sqrt(n),
    # Calculate 95% CI
    t_crit = qt(0.975, df = pmax(n - 1, 1)),
    cum_loss_ci = t_crit * cum_loss_se,
    .groups = "drop"
  )

# 4. Significance Testing (Daily)
daily_leaching_sig <- leaching_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  mutate(
    Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment),
    daily_n_loss_kgha = (total_n_loss_mg / 1e6) / plot_area_ha
  ) |>
  group_by(year, date) |>
  summarise(
    p_value = {
      sorg <- daily_n_loss_kgha[Treatment == "Sorghum"]
      wcc  <- daily_n_loss_kgha[Treatment == "Sorghum + WCC"]
      if (length(na.omit(sorg)) >= 3 && length(na.omit(wcc)) >= 3) {
        tryCatch(wilcox.test(sorg, wcc)$p.value, error = function(e) NA)
      } else NA
    },
    .groups = "drop"
  ) |>
  mutate(
    star_label = if_else(!is.na(p_value) & p_value < 0.05, "*", "")
  )

# 5. Prepare Plot Data (Stars & Precip)
leaching_stars <- daily_leaching_summary |>
  group_by(year, date) |>
  summarise(max_y = max(mean_loss + se_loss, na.rm = TRUE), .groups = "drop") |>
  inner_join(daily_leaching_sig, by = c("year", "date")) |>
  filter(star_label == "*") |>
  mutate(star_y = max_y * 1.1)

daily_precip_leaching <- rain |>
  filter(year %in% c(2023, 2024)) |>
  group_by(year) |>
  filter(date >= min(leaching_data$date) & date <= max(leaching_data$date)) |>
  ungroup()

# Scaling factors
max_leach <- max(daily_leaching_summary$mean_loss + daily_leaching_summary$se_loss, na.rm = TRUE)
max_precip_l <- max(daily_precip_leaching$precipmm, na.rm = TRUE)
scale_factor_l <- (max_leach * 0.4) / max_precip_l
plot_top_l <- max_leach * 1.1
max_cum_leach <- max(cum_leaching_summary$cum_loss_mean + cum_leaching_summary$cum_loss_ci, na.rm = TRUE)

# 6. Plotting Function
create_leaching_plot <- function(year_val, is_right_panel = FALSE) {
  # Data subsets
  d_sub <- filter(daily_leaching_summary, year == year_val)
  c_sub <- filter(cum_leaching_summary, year == year_val)
  p_sub <- filter(daily_precip_leaching, year == year_val)
  s_sub <- filter(leaching_stars, year == year_val)
  
  x_lims <- as.Date(paste0(year_val, c("-01-01", "-12-31")))
  
  # Top Panel: Daily Leaching + Precip
  p_daily <- ggplot() +
    # Precip bars (inverted from top)
    geom_rect(
      data = p_sub,
      aes(xmin = date - 0.5, xmax = date + 0.5, 
          ymin = plot_top_l - (precipmm * scale_factor_l), ymax = plot_top_l),
      fill = "#377EB8", alpha = 0.7
    ) +
    # Leaching points & errors
    geom_point(data = d_sub, aes(x = date, y = mean_loss, color = Treatment), size = 1.5) +
    geom_errorbar(
      data = d_sub, 
      aes(x = date, ymin = mean_loss - se_loss, ymax = mean_loss + se_loss, color = Treatment),
      width = 0.2, alpha = 0.5
    ) +
    # Significance stars
    geom_text(data = s_sub, aes(x = date, y = star_y, label = star_label), size = 5) +
    scale_color_manual(values = treatment_colors) +
    scale_x_date(date_breaks = "2 months", date_labels = "%b", limits = x_lims) +
    scale_y_continuous(
      name = if(!is_right_panel) expression("Daily N Loss (kg N ha"^-1*" d"^-1*")") else "",
      limits = c(0, plot_top_l),
      sec.axis = sec_axis(~ (plot_top_l - .) / scale_factor_l, 
                          name = if(is_right_panel) "Precipitation (mm)" else "")
    ) +
    theme_publication(base_size = 10) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      legend.position = "none",
      axis.line.x = element_blank(),
      axis.title.y.right = element_text(color = "#377EB8"),
      axis.text.y.right = element_text(color = "#377EB8")
    )
    
  if(is_right_panel) {
    p_daily <- p_daily + theme(
      axis.text.y.left = element_blank(),
      axis.ticks.y.left = element_blank(),
      axis.line.y.left = element_blank()
    )
  } else {
    p_daily <- p_daily + theme(
      axis.text.y.right = element_blank(),
      axis.ticks.y.right = element_blank()
    )
  }

  # Bottom Panel: Cumulative Leaching
  p_cum <- ggplot(c_sub, aes(x = date, y = cum_loss_mean, color = Treatment, fill = Treatment)) +
    geom_ribbon(
      aes(ymin = pmax(cum_loss_mean - cum_loss_ci, 0), ymax = cum_loss_mean + cum_loss_ci),
      alpha = 0.15, linewidth = 0
    ) +
    geom_line(linewidth = 1) +
    scale_color_manual(values = treatment_colors) +
    scale_fill_manual(values = treatment_colors) +
    scale_x_date(date_breaks = "2 months", date_labels = "%b", limits = x_lims) +
    scale_y_continuous(
      name = if(!is_right_panel) expression("Cumulative N Loss (kg N ha"^-1*")") else "",
      limits = c(0, max_cum_leach)
    ) +
    labs(x = "Month") +
    theme_publication(base_size = 10) +
    theme(legend.position = "none")

  if(is_right_panel) {
    p_cum <- p_cum + theme(
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(), 
      axis.line.y = element_blank()
    )
  }

  p_daily / p_cum + plot_layout(heights = c(1.2, 1))
}

# 7. Assemble Figure
fig_leaching <- (create_leaching_plot(2023) | create_leaching_plot(2024, TRUE)) +
  plot_layout(guides = "collect") &
  theme(legend.position = "top", legend.justification = "center")

fig_leaching

ggsave("figures/figure3_leaching_precip.png", fig_leaching,
       width = 174, height = 174, units = "mm", dpi = 600, bg = "white")
```

# Check Leaching error ribbons compared to figure3_dual_axis_leaching_precip.r

# Figure 5: Nitrate Leaching and Precipitation

```{r}
# 1. Load and Process Leaching Data
# Define plot area constants
plot_area_ft2 <- 120 * 160
plot_area_ha <- plot_area_ft2 / 107639.1041671

leaching_data <- read_csv("data/clean_leaching.csv") |>
  janitor::clean_names() |>
  mutate(
    date = as.Date(date),
    year = year(date)
  ) |>
  filter(year %in% c(2023, 2024))

# 2. Daily Leaching Calculation
daily_leaching_summary <- leaching_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  mutate(
    Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment),
    daily_n_loss_kgha = (total_n_loss_mg / 1e6) / plot_area_ha
  ) |>
  group_by(Treatment, year, date) |>
  summarise(
    mean_loss = mean(daily_n_loss_kgha, na.rm = TRUE),
    se_loss = sd(daily_n_loss_kgha, na.rm = TRUE) / sqrt(sum(!is.na(daily_n_loss_kgha))),
    .groups = "drop"
  )

# 3. Cumulative Leaching Calculation
# Updated to match Figure 3 R script logic (using SE for ribbons, not 95% CI)
cum_leaching_summary <- leaching_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  mutate(
    Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment),
    cum_loss_kgha = (cumulative_n_loss_mg / 1e6) / plot_area_ha
  ) |>
  group_by(Treatment, year, date) |>
  summarise(
    cum_loss_mean = mean(cum_loss_kgha, na.rm = TRUE),
    cum_loss_sd = sd(cum_loss_kgha, na.rm = TRUE),
    n = n(),
    # Use standard error for ribbons
    cum_loss_se = cum_loss_sd / sqrt(n), 
    .groups = "drop"
  )

# 4. Significance Testing (Daily)
daily_leaching_sig <- leaching_data |>
  filter(treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  mutate(
    Treatment = if_else(treatment == "Sorghum + Rye", "Sorghum + WCC", treatment),
    daily_n_loss_kgha = (total_n_loss_mg / 1e6) / plot_area_ha
  ) |>
  group_by(year, date) |>
  summarise(
    p_value = {
      sorg <- daily_n_loss_kgha[Treatment == "Sorghum"]
      wcc  <- daily_n_loss_kgha[Treatment == "Sorghum + WCC"]
      if (length(na.omit(sorg)) >= 3 && length(na.omit(wcc)) >= 3) {
        tryCatch(wilcox.test(sorg, wcc)$p.value, error = function(e) NA)
      } else NA
    },
    .groups = "drop"
  ) |>
  mutate(
    star_label = if_else(!is.na(p_value) & p_value < 0.05, "*", "")
  )

# 5. Prepare Plot Data (Stars & Precip)
leaching_stars <- daily_leaching_summary |>
  group_by(year, date) |>
  summarise(max_y = max(mean_loss + se_loss, na.rm = TRUE), .groups = "drop") |>
  inner_join(daily_leaching_sig, by = c("year", "date")) |>
  filter(star_label == "*") |>
  mutate(star_y = max_y * 1.1)

daily_precip_leaching <- rain |>
  filter(year %in% c(2023, 2024)) |>
  group_by(year) |>
  filter(date >= min(leaching_data$date) & date <= max(leaching_data$date)) |>
  ungroup()

# Scaling factors (match R script logic)
max_leach <- max(daily_leaching_summary$mean_loss + daily_leaching_summary$se_loss, na.rm = TRUE)
max_precip_l <- max(daily_precip_leaching$precipmm, na.rm = TRUE)
scale_factor_l <- (max_leach * 0.4) / max_precip_l
plot_top_l <- max_leach * 1.1

# Updated scaling for ribbons using SE
max_cum_leach <- max(cum_leaching_summary$cum_loss_mean + cum_leaching_summary$cum_loss_se, na.rm = TRUE)

# 6. Plotting Function
create_leaching_plot <- function(year_val, is_right_panel = FALSE) {
  # Data subsets
  d_sub <- filter(daily_leaching_summary, year == year_val)
  c_sub <- filter(cum_leaching_summary, year == year_val)
  p_sub <- filter(daily_precip_leaching, year == year_val)
  s_sub <- filter(leaching_stars, year == year_val)
  fert_year <- filter(fert_events, year == year_val)

  
  x_lims <- as.Date(paste0(year_val, c("-01-01", "-12-31")))
  
  # Top Panel: Daily Leaching + Precip
  p_daily <- ggplot() +
    # Precip bars
    geom_rect(
      data = p_sub,
      aes(xmin = date - 0.5, xmax = date + 0.5, 
          ymin = plot_top_l - (precipmm * scale_factor_l), ymax = plot_top_l),
      fill = "#377EB8", alpha = 0.7
    ) +
    # Leaching points & errors
    geom_point(data = d_sub, aes(x = date, y = mean_loss, color = Treatment), size = 1.5) +
    geom_errorbar(
      data = d_sub, 
      aes(x = date, ymin = mean_loss - se_loss, ymax = mean_loss + se_loss, color = Treatment),
      width = 0.2, alpha = 0.5
    ) +
    geom_vline(
      data = fert_year,
      aes(xintercept = fertilizer_date),
      linetype = "dashed",
      color = "black",
      alpha = 0.7
    ) +
    # Significance stars
    geom_text(data = s_sub, aes(x = date, y = star_y, label = star_label), size = 5) +
    scale_color_manual(values = treatment_colors) +
    scale_x_date(date_breaks = "2 months", date_labels = "%b", limits = x_lims) +
    scale_y_continuous(
      name = if(!is_right_panel) expression("Daily N Loss (kg N ha"^-1*" d"^-1*")") else "",
      limits = c(0, plot_top_l),
      sec.axis = sec_axis(~ (plot_top_l - .) / scale_factor_l, 
                          name = if(is_right_panel) "Precipitation (mm)" else "")
    ) +
    theme_publication(base_size = 10) +
    theme(
      legend.position = "none",
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.line.x = element_blank(),
      axis.text.y = if (is_right_panel) element_blank() else element_text(),
      axis.ticks.y = if (is_right_panel) element_blank() else element_line(),
      axis.line.y = if (is_right_panel) element_blank() else element_line(),
      axis.title.y = if (is_right_panel) element_blank() else element_text(),
      axis.text.y.right = if (is_right_panel) {
        element_text(color = "#377EB8")
      } else {
        element_blank()
      },
      axis.ticks.y.right = if (is_right_panel) {
        element_line()
      } else {
        element_blank()
      },
      axis.title.y.right = if (is_right_panel) {
        element_text(color = "#377EB8")
      } else {
        element_blank()
      }
    ) +
    labs(x = "") +
    geom_hline(yintercept = 0, linetype = "solid", alpha = 0.3)
    
  if(is_right_panel) {
    p_daily <- p_daily + theme(
      axis.text.y.left = element_blank(),
      axis.ticks.y.left = element_blank(),
      axis.line.y.left = element_blank()
    )
  } else {
    p_daily <- p_daily + theme(
      axis.text.y.right = element_blank(),
      axis.ticks.y.right = element_blank()
    )
  }

  # Bottom Panel: Cumulative Leaching (Updated)
  p_cum <- ggplot(c_sub, aes(x = date, y = cum_loss_mean, color = Treatment, fill = Treatment)) +
    geom_ribbon(
      # CHANGED: Using SE instead of CI to match R script
      aes(ymin = pmax(cum_loss_mean - cum_loss_se, 0), ymax = cum_loss_mean + cum_loss_se),
      alpha = 0.15, linewidth = 0
    ) +
    geom_line(linewidth = 1) +
    geom_vline(
      data = fert_year,
      aes(xintercept = fertilizer_date),
      linetype = "dashed",
      color = "black",
      alpha = 0.7
    ) +
    scale_color_manual(values = treatment_colors) +
    scale_fill_manual(values = treatment_colors) +
    scale_x_date(date_breaks = "2 months", date_labels = "%b", limits = x_lims) +
    scale_y_continuous(
      name = if(!is_right_panel) expression("Cumulative N Loss (kg N ha"^-1*")") else "",
      limits = c(0, max_cum_leach)
    ) +
    labs(x = "Month") +
    theme_publication(base_size = 10) +
    theme(legend.position = "none")

  if(is_right_panel) {
    p_cum <- p_cum + theme(
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(), 
      axis.line.y = element_blank()
    )
  }

  p_daily / p_cum + plot_layout(heights = c(1.2, 1))
}

# 7. Assemble Figure
fig_leaching <- (create_leaching_plot(2023) | create_leaching_plot(2024, TRUE)) +
  plot_layout(guides = "collect") &
  theme(legend.position = "top", legend.justification = "center")

fig_leaching

ggsave("figures/figure3_leaching_precip.png", fig_leaching,
       width = 174, height = 174, units = "mm", dpi = 600, bg = "white")
```

# Table 3: Annual Nitrogen Losses

```{r table3-nitrogen-losses}
#| message: FALSE
#| warning: FALSE

library(gt)
library(emmeans)
library(multcomp)

# --- 1. N2O Data Processing (Interpolation & Cumulative) ---

# Summarize daily flux by plot/date
daily_flux_summary <- flux_data |>
  group_by(plot, rowvs_interrow, treatment, year, date) |>
  summarise(mean_flux = mean(gnha_day_no_negative, na.rm = TRUE), .groups = "drop") |>
  arrange(plot, rowvs_interrow, treatment, year, date)

# Interpolation helper function
interpolate_daily_flux <- function(data) {
  # Get unique plot combinations
  plot_combinations <- data |>
    distinct(plot, rowvs_interrow, treatment, year)
  
  purrr::map_dfr(seq_len(nrow(plot_combinations)), function(i) {
    combo <- plot_combinations[i, ]
    
    subset_data <- data |>
      filter(
        plot == combo$plot,
        rowvs_interrow == combo$rowvs_interrow,
        treatment == combo$treatment,
        year == combo$year
      ) |>
      arrange(date)
    
    # Create full year sequence
    start_date <- as.Date(paste0(combo$year, "-01-01"))
    end_date <- as.Date(paste0(combo$year, "-12-31"))
    all_days <- seq(start_date, end_date, by = "day")
    
    # Interpolate if we have sufficient data
    if (nrow(subset_data) >= 2 && !all(is.na(subset_data$mean_flux))) {
      valid_data <- subset_data[!is.na(subset_data$mean_flux), ]
      
      if (nrow(valid_data) >= 2) {
        interpolated_flux <- approx(
          x = as.numeric(valid_data$date),
          y = valid_data$mean_flux,
          xout = as.numeric(all_days),
          rule = 1
        )$y
      } else {
        interpolated_flux <- rep(NA_real_, length(all_days))
      }
    } else {
      interpolated_flux <- rep(NA_real_, length(all_days))
    }
    
    tibble(
      plot = combo$plot,
      rowvs_interrow = combo$rowvs_interrow,
      treatment = combo$treatment,
      year = combo$year,
      date = all_days,
      interpolated_flux = interpolated_flux
    )
  })
}

# Apply interpolation
interpolated_flux_data <- interpolate_daily_flux(daily_flux_summary)

# Calculate cumulative N2O per plot (g -> kg)
plot_cumulative_n2o <- interpolated_flux_data |>
  group_by(plot, rowvs_interrow, treatment, year) |>
  summarise(
    annual_cumulative_n2o = sum(interpolated_flux, na.rm = TRUE) / 1000, 
    .groups = "drop"
  ) |>
  filter(is.finite(annual_cumulative_n2o))

# --- 2. Leaching Data Processing ---

# Ensure leaching data is available (re-load if necessary)
if (!exists("leaching_data")) {
  leaching_data <- read_csv("data/clean_leaching.csv") |>
    janitor::clean_names() |>
    mutate(
      date = as.Date(date),
      year = year(date)
    ) |>
    filter(year %in% c(2023, 2024))
}

# Calculate annual cumulative nitrogen leaching per plot
plot_area_ft2 <- 120 * 160
plot_area_ha <- plot_area_ft2 / 107639.1041671

annual_leaching <- leaching_data |>
  group_by(plot, treatment, year) |>
  summarise(
    # mg -> kg, then divide by hectares
    annual_cumulative_leaching = (max(cumulative_n_loss_mg, na.rm = TRUE) / 1e6) / plot_area_ha, 
    .groups = "drop",
    annual_drainage_l = max(cumulative_flow_l, na.rm = TRUE),
    annual_drainage_mm = (annual_drainage_l / plot_area_ha) / 10000
  ) |>
  filter(is.finite(annual_cumulative_leaching), annual_cumulative_leaching >= 0)

# --- 3. Statistical Summaries and Letters ---

# Summarize by treatment and year
n2o_summary <- plot_cumulative_n2o |>
  group_by(treatment, year) |>
  summarise(
    n_plots = n(),
    mean_n2o = mean(annual_cumulative_n2o, na.rm = TRUE),
    sd_n2o = sd(annual_cumulative_n2o, na.rm = TRUE),
    .groups = "drop"
  )

leaching_summary <- annual_leaching |>
  group_by(treatment, year) |>
  summarise(
    n_plots = n(),
    mean_leaching = mean(annual_cumulative_leaching, na.rm = TRUE),
    sd_leaching = sd(annual_cumulative_leaching, na.rm = TRUE),
    .groups = "drop"
  )

# Helper: Compute Tukey letters within year
compute_letters_by_year <- function(df, value_col) {
  d <- df |> filter(!is.na(.data[[value_col]]))
  trts <- sort(unique(d$treatment))
  if (length(trts) < 2) return(tibble(treatment = trts, letter = "a"))
  
  fml <- as.formula(paste(value_col, "~ treatment"))
  fit <- lm(fml, data = d)
  emm <- emmeans::emmeans(fit, ~ treatment)
  
  if (requireNamespace("multcomp", quietly = TRUE)) {
    out <- multcomp::cld(emm, adjust = "tukey", Letters = letters) |>
      as_tibble() |>
      transmute(treatment, letter = gsub("\\s+", "", .group)) |>
      mutate(
        letter = ifelse(grepl("[0-9]", letter), chartr("123456789", "abcdefghi", letter), letter),
        letter = ifelse(letter == "" | is.na(letter), "a", letter)
      )
  } else {
    out <- tibble(treatment = trts, letter = "a")
  }
  out
}

# Calculate letters
leach_letters <- annual_leaching |>
  group_by(year) |>
  group_modify(~ compute_letters_by_year(.x, "annual_cumulative_leaching")) |>
  ungroup()

n2o_letters <- plot_cumulative_n2o |>
  group_by(year) |>
  group_modify(~ compute_letters_by_year(.x, "annual_cumulative_n2o")) |>
  ungroup()

# Join letters (only show for annual rows, not 2-year total later)
leaching_summary <- leaching_summary |>
  left_join(leach_letters, by = c("treatment", "year")) |>
  mutate(leaching_result = sprintf("%.3f ± %.3f (%s)", mean_leaching, sd_leaching, letter))

n2o_summary <- n2o_summary |>
  left_join(n2o_letters, by = c("treatment", "year")) |>
  mutate(n2o_result = sprintf("%.3f ± %.3f (%s)", mean_n2o, sd_n2o, letter))

# Calculate 2-Year Totals (Sum of Means, SD via Quadrature)
n2o_two_year <- n2o_summary |>
  filter(year %in% c(2023, 2024)) |>
  group_by(treatment) |>
  summarise(
    mean_n2o = sum(mean_n2o, na.rm = TRUE),
    sd_n2o = sqrt(sum(sd_n2o^2, na.rm = TRUE)),
    .groups = "drop"
  ) |>
  mutate(year = "2023-2024", n2o_result = sprintf("%.3f ± %.3f", mean_n2o, sd_n2o))

leaching_two_year <- leaching_summary |>
  filter(year %in% c(2023, 2024)) |>
  group_by(treatment) |>
  summarise(
    mean_leaching = sum(mean_leaching, na.rm = TRUE),
    sd_leaching = sqrt(sum(sd_leaching^2, na.rm = TRUE)),
    .groups = "drop"
  ) |>
  mutate(year = "2023-2024", leaching_result = sprintf("%.3f ± %.3f", mean_leaching, sd_leaching))

# --- 4. Organize Data for Table ---

# Extract numeric means for Cost calculation
n2o_means <- bind_rows(
  n2o_summary |> mutate(year = as.character(year)) |> select(year, treatment, mean_n2o),
  n2o_two_year |> select(year, treatment, mean_n2o)
)

leaching_means <- bind_rows(
  leaching_summary |> mutate(year = as.character(year)) |> select(year, treatment, mean_leaching),
  leaching_two_year |> select(year, treatment, mean_leaching)
)

# Combine textual results
combined_nitrogen_data <- bind_rows(
  n2o_summary |> mutate(year = as.character(year)) |> select(year, treatment, n2o_result),
  n2o_two_year |> select(year, treatment, n2o_result)
) |>
  full_join(
    bind_rows(
      leaching_summary |> mutate(year = as.character(year)) |> select(year, treatment, leaching_result),
      leaching_two_year |> select(year, treatment, leaching_result)
    ),
    by = c("year", "treatment")
  ) |>
  left_join(n2o_means, by = c("year", "treatment")) |>
  left_join(leaching_means, by = c("year", "treatment")) |>
  mutate(
    year_order = case_when(year == "2023" ~ 1, year == "2024" ~ 2, year == "2023-2024" ~ 3),
    # Preza-Fontes cost values
    environmental_cost_dollars = (mean_n2o * 16.18) + (mean_leaching * 18.54),
    total_environmental_cost = sprintf("$%.2f", environmental_cost_dollars)
  )

# ANOVA / Source of Variation
combined_n2o_data <- plot_cumulative_n2o |> mutate(year_factor = as.factor(year))
aov_n2o <- aov(annual_cumulative_n2o ~ year_factor * treatment, data = combined_n2o_data)

combined_leaching_data <- annual_leaching |> mutate(year_factor = as.factor(year))
aov_leaching <- aov(annual_cumulative_leaching ~ year_factor * treatment, data = combined_leaching_data)

source_variation_n <- tibble(
  source = c("Year", "Treatment", "Year × Treatment"),
  n2o_p = summary(aov_n2o)[[1]][1:3, "Pr(>F)"],
  leaching_p = summary(aov_leaching)[[1]][1:3, "Pr(>F)"]
) |>
  mutate(
    across(c(n2o_p, leaching_p), ~ case_when(
      .x < 0.001 ~ "< 0.001",
      .x < 0.01 ~ sprintf("%.3f", .x),
      TRUE ~ sprintf("%.2f", .x)
    )),
    year = "", year_order = 4, treatment = source,
    n2o_result = n2o_p, leaching_result = leaching_p, 
    total_environmental_cost = ""
  ) |>
  select(-source, -n2o_p, -leaching_p)

# Assemble Complete Table
separator_n <- tibble(
  year = "Source of Variation", year_order = 3.5, treatment = "",
  n2o_result = "", leaching_result = "", total_environmental_cost = ""
)

table3_complete <- bind_rows(
  combined_nitrogen_data, separator_n, source_variation_n
) |>
  arrange(year_order, treatment) |>
  mutate(
    year_display = case_when(
      year == "Source of Variation" ~ year,
      year != lag(year, default = "") ~ as.character(year),
      TRUE ~ ""
    ),
    is_new_section = year != lag(year, default = "") & year != "Source of Variation"
  )

# --- 5. Generate GT Table ---

table3_gt <- table3_complete |>
  select(
    Year = year_display,
    Treatment = treatment,
    `N2O Loss` = n2o_result,
    `N Leaching` = leaching_result, 
    `Total Environmental Cost` = total_environmental_cost,
    is_new_section
  ) |>
  gt() |>
  tab_header(title = md("**Table 3. Annual nitrogen losses**")) |>
  cols_label(
    `N2O Loss` = md("N<sub>2</sub>O Loss<br>(kg N ha<sup>-1</sup>)"),
    `N Leaching` = md("N Leaching<br>(kg N ha<sup>-1</sup>)"),
    `Total Environmental Cost` = md("Total Environmental Cost<br>(USD ha<sup>-1</sup>)")
  ) |>
  tab_style(
    style = cell_borders(sides = "top", weight = px(1), color = "gray"),
    locations = cells_body(rows = is_new_section == TRUE)
  ) |>
  cols_width(
    Year ~ px(90), Treatment ~ px(150),
    `N2O Loss` ~ px(160), `N Leaching` ~ px(160), 
    `Total Environmental Cost` ~ px(160)
  ) |>
  tab_style(
    style = cell_borders(sides = "top", weight = px(2)),
    locations = cells_body(rows = Year == "Source of Variation")
  ) |>
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(rows = Year == "Source of Variation")  
  ) |>
  cols_hide(columns = is_new_section) |>
  tab_footnote(
    footnote = "Values are mean ± standard deviation. Letters (in parentheses) indicate Tukey-adjusted groups within year (α = 0.05). Two-year totals (2023–202# Table 3: Annual Nitrogen Losses")

# print table
table3_gt

```

```{r}
library(dplyr)
library(tidyr)
library(gt)
library(emmeans)
library(multcomp)

# --- 1. PREPARE PLOT-LEVEL DATA (JOINING N2O & LEACHING) ---

# A. Aggregate N2O to single Plot value (averaging row/interrow)
n2o_plot_clean <- plot_cumulative_n2o |>
  group_by(year, plot, treatment) |>
  summarise(
    n2o_kg_ha = mean(annual_cumulative_n2o, na.rm = TRUE),
    .groups = "drop"
  )

# B. Prepare Leaching (already plot level)
leach_plot_clean <- annual_leaching |>
  select(year, plot, treatment, leaching_kg_ha = annual_cumulative_leaching)

# C. Join and Calculate Plot-Level EDC
# Costs: N2O = $16.18/kg N, Leaching = $18.54/kg N (Preza-Fontes et al.)
plot_level_economics <- n2o_plot_clean |>
  inner_join(leach_plot_clean, by = c("year", "plot", "treatment")) |>
  mutate(
    edc_dollars = (n2o_kg_ha * 16.18) + (leaching_kg_ha * 18.54)
  )

# --- 2. PREPARE "2-YEAR TOTAL" DATA FOR STATS ---

# We sum the 2023 and 2024 values for each plot to test the "Combined" effect
plot_level_2year <- plot_level_economics |>
  filter(year %in% c(2023, 2024)) |>
  group_by(plot, treatment) |>
  summarise(
    n2o_kg_ha = sum(n2o_kg_ha, na.rm = TRUE),
    leaching_kg_ha = sum(leaching_kg_ha, na.rm = TRUE),
    edc_dollars = sum(edc_dollars, na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(year = "2023-2024") # Label for the table

# Combine Annual and 2-Year Data into one master dataset for stats
master_stats_data <- bind_rows(
  plot_level_economics |> mutate(year = as.character(year)),
  plot_level_2year
)

# --- 3. STATS LOOP (Calculate Means + Letters for ALL 3 Columns) ---

# Helper function: Linear Model + Tukey Letters
get_stats_with_letters <- function(df, val_col) {
  # 1. Calculate Means & SD
  summ <- df |>
    group_by(treatment) |>
    summarise(
      mean_val = mean(.data[[val_col]], na.rm = TRUE),
      sd_val = sd(.data[[val_col]], na.rm = TRUE),
      .groups = "drop"
    )
  
  # 2. Generate Letters (LM -> Emmeans -> CLD)
  # Fit model
  fit <- lm(as.formula(paste(val_col, "~ treatment")), data = df)
  
  # Get letters
  letters_df <- tryCatch({
    fit |>
      emmeans(~ treatment) |>
      cld(adjust = "tukey", Letters = letters, alpha = 0.05) |>
      as_tibble() |>
      mutate(letter = trimws(.group)) |>
      select(treatment, letter)
  }, error = function(e) {
    tibble(treatment = unique(df$treatment), letter = "")
  })
  
  # 3. Join
  left_join(summ, letters_df, by = "treatment")
}

# Run the loop for each Year (2023, 2024, 2023-2024) and each Variable
final_table_data <- master_stats_data |>
  group_by(year) |>
  group_modify(~ {
    # N2O Stats
    n2o <- get_stats_with_letters(.x, "n2o_kg_ha") |>
      mutate(n2o_str = sprintf("%.2f \u00B1 %.2f (%s)", mean_val, sd_val, letter)) |>
      select(treatment, n2o_str)
    
    # Leaching Stats
    leach <- get_stats_with_letters(.x, "leaching_kg_ha") |>
      mutate(leach_str = sprintf("%.2f \u00B1 %.2f (%s)", mean_val, sd_val, letter)) |>
      select(treatment, leach_str)
    
    # EDC Stats (The new addition!)
    edc <- get_stats_with_letters(.x, "edc_dollars") |>
      mutate(edc_str = sprintf("$%.2f \u00B1 %.2f (%s)", mean_val, sd_val, letter)) |>
      select(treatment, edc_str)
    
    # Merge them all
    n2o |> left_join(leach, by="treatment") |> left_join(edc, by="treatment")
  }) |>
  ungroup()

# --- 4. FORMATTING THE GT TABLE ---

# Re-calculate ANOVA P-values for the footer (Global Model)
# Note: This is just for the footer P-values
aov_edc <- aov(edc_dollars ~ as.factor(year) * treatment, data = plot_level_economics)
p_trt_edc <- summary(aov_edc)[[1]]["treatment", "Pr(>F)"]

final_table_data |>
  mutate(
    year_order = case_when(year == "2023" ~ 1, year == "2024" ~ 2, TRUE ~ 3)
  ) |>
  arrange(year_order, treatment) |>
  select(Year = year, Treatment = treatment, `N2O Loss` = n2o_str, `N Leaching` = leach_str, `Env. Damage Cost` = edc_str) |>
  gt() |>
  tab_header(title = md("**Table 3. Annual nitrogen losses and environmental costs**")) |>
  cols_label(
    `N2O Loss` = md("N<sub>2</sub>O Loss<br>(kg N ha<sup>-1</sup>)"),
    `N Leaching` = md("N Leaching<br>(kg N ha<sup>-1</sup>)"),
    `Env. Damage Cost` = md("Total Environmental Cost<br>(USD ha<sup>-1</sup>)")
  ) |>
  cols_align(align = "center", columns = -Treatment) |>
  tab_style(
    style = cell_borders(sides = "top", color = "gray"),
    locations = cells_body(rows = Year != lag(Year, default = ""))
  ) |>
  tab_footnote(
    footnote = md(sprintf(
      "Values are mean ± SD. Letters indicate Tukey-adjusted groups within year/period (α=0.05). Costs: N₂O ($16.18/kg N) + Leaching ($18.54/kg N). Global ANOVA Treatment effect for Cost: p = %.3f.", 
      p_trt_edc
    ))
  )
```

```{r}
library(dplyr)
library(tidyr)
library(gt)
library(emmeans)
library(multcomp)

# --- 1. PREPARE PLOT-LEVEL DATA (Averaging Row/Interrow) ---

# N2O: Average Row/Interrow daily, THEN sum for the year
n2o_plot <- interpolated_flux_data |>
  group_by(plot, treatment, year, date) |>
  summarise(daily_plot_flux = mean(interpolated_flux, na.rm = TRUE), .groups = "drop") |>
  group_by(plot, treatment, year) |>
  summarise(
    n2o_kg_ha = sum(daily_plot_flux, na.rm = TRUE) / 1000, 
    .groups = "drop"
  )

# Leaching: Ensure Plot Level
leach_plot <- annual_leaching |>
  select(year, plot, treatment, leaching_kg_ha = annual_cumulative_leaching)

# Join & Calculate Plot EDC
plot_economics <- n2o_plot |>
  inner_join(leach_plot, by = c("year", "plot", "treatment")) |>
  mutate(edc_dollars = (n2o_kg_ha * 16.18) + (leaching_kg_ha * 18.54))

# --- 2. CALCULATE 2-YEAR TOTALS (Method of Moments) ---

# A. Continuous Systems (Real Sums)
continuous_2year <- plot_economics |>
  filter(year %in% c(2023, 2024), treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  group_by(plot, treatment) |>
  summarise(
    n2o_kg_ha = sum(n2o_kg_ha, na.rm = TRUE),
    leaching_kg_ha = sum(leaching_kg_ha, na.rm = TRUE),
    edc_dollars = sum(edc_dollars, na.rm = TRUE),
    count = n(),
    .groups = "drop"
  ) |>
  filter(count == 2) |>
  select(-count)

# B. Rotation Systems (Variance Propagation)
# Annual stats (using all plots)
rotation_annual_stats <- plot_economics |>
  filter(year %in% c(2023, 2024), treatment %in% c("Corn", "Soy")) |>
  group_by(treatment, year) |>
  summarise(
    mu_n2o = mean(n2o_kg_ha, na.rm = TRUE), var_n2o = var(n2o_kg_ha, na.rm = TRUE),
    mu_leach = mean(leaching_kg_ha, na.rm = TRUE), var_leach = var(leaching_kg_ha, na.rm = TRUE),
    mu_edc = mean(edc_dollars, na.rm = TRUE), var_edc = var(edc_dollars, na.rm = TRUE),
    .groups = "drop"
  )

# Propagate to 2-Year Totals
rotation_2year_stats <- rotation_annual_stats |>
  group_by(treatment) |>
  summarise(
    final_mu_n2o = sum(mu_n2o), final_sd_n2o = sqrt(sum(var_n2o)),
    final_mu_leach = sum(mu_leach), final_sd_leach = sqrt(sum(var_leach)),
    final_mu_edc = sum(mu_edc), final_sd_edc = sqrt(sum(var_edc)),
    .groups = "drop"
  )

# Synthetic Plots for ANOVA (n=3)
rotation_synthetic_plots <- rotation_2year_stats |>
  group_by(treatment) |>
  group_modify(~ {
    n_sim <- 3
    make_dist <- function(n, mu, sd) {
      x <- rnorm(n)
      if(sd > 0) x_final <- ((x - mean(x)) / sd(x)) * sd + mu else x_final <- rep(mu, n)
      return(pmax(0, x_final))
    }
    tibble(
      plot = paste0("Syn_", 1:n_sim),
      n2o_kg_ha = make_dist(n_sim, .x$final_mu_n2o, .x$final_sd_n2o),
      leaching_kg_ha = make_dist(n_sim, .x$final_mu_leach, .x$final_sd_leach),
      edc_dollars = make_dist(n_sim, .x$final_mu_edc, .x$final_sd_edc)
    )
  }) |>
  ungroup()

# Combine Real + Synthetic
final_2year_data <- bind_rows(continuous_2year, rotation_synthetic_plots) |>
  mutate(year = "2023-2024")

# Master Dataset
stats_input_data <- bind_rows(
  plot_economics |> mutate(year = as.character(year)),
  final_2year_data
)

# --- 3. STATISTICAL LOOP (3 SIG FIGS) ---

calc_stat_column <- function(data, col_name, is_money = FALSE) {
  # Fit Model
  fit <- lm(as.formula(paste(col_name, "~ treatment")), data = data)
  
  # Get Letters
  lets <- tryCatch({
    emmeans(fit, ~ treatment) |>
      cld(adjust = "tukey", Letters = letters, alpha = 0.05) |>
      as_tibble() |>
      mutate(letter = trimws(.group)) |>
      select(treatment, letter)
  }, error = function(e) tibble(treatment = unique(data$treatment), letter = ""))
  
  # Get Summary Stats & Format to 3 Sig Figs
  data |>
    group_by(treatment) |>
    summarise(mean = mean(.data[[col_name]], na.rm = TRUE), sd = sd(.data[[col_name]], na.rm = TRUE), .groups = "drop") |>
    left_join(lets, by = "treatment") |>
    mutate(
      # Formatting Logic: 3 Significant Figures
      mean_str = formatC(signif(mean, 3), digits = 3, format = "fg", flag = "#"),
      sd_str = formatC(signif(sd, 3), digits = 3, format = "fg", flag = "#"),
      # Remove trailing dots (e.g., "123." -> "123")
      mean_str = sub("\\.$", "", mean_str),
      sd_str = sub("\\.$", "", sd_str),
      
      result_str = if(is_money) {
        sprintf("$%s \u00B1 %s (%s)", mean_str, sd_str, letter)
      } else {
        sprintf("%s \u00B1 %s (%s)", mean_str, sd_str, letter)
      }
    ) |>
    select(treatment, result_str)
}

# Run Loop
table_body <- stats_input_data |>
  group_by(year) |>
  group_modify(~ {
    n2o <- calc_stat_column(.x, "n2o_kg_ha")
    leach <- calc_stat_column(.x, "leaching_kg_ha")
    edc <- calc_stat_column(.x, "edc_dollars", is_money = TRUE)
    n2o |> rename(N2O = result_str) |>
      left_join(leach |> rename(Leach = result_str), by = "treatment") |>
      left_join(edc |> rename(Cost = result_str), by = "treatment")
  }) |>
  ungroup()

# --- 4. SOURCE OF VARIATION ---
# (Using plot_economics for correct global stats)
aov_n2o <- summary(aov(n2o_kg_ha ~ as.factor(year) * treatment, data = plot_economics))[[1]]
aov_leach <- summary(aov(leaching_kg_ha ~ as.factor(year) * treatment, data = plot_economics))[[1]]
aov_edc <- summary(aov(edc_dollars ~ as.factor(year) * treatment, data = plot_economics))[[1]]

format_p <- function(p) ifelse(p < 0.001, "< 0.001", sprintf("%.3f", p))

source_var <- tibble(
  year = "Source of Variation",
  treatment = c("Treatment", "Year", "Year × Treatment"),
  N2O = c(format_p(aov_n2o[2, "Pr(>F)"]), format_p(aov_n2o[1, "Pr(>F)"]), format_p(aov_n2o[3, "Pr(>F)"])),
  Leach = c(format_p(aov_leach[2, "Pr(>F)"]), format_p(aov_leach[1, "Pr(>F)"]), format_p(aov_leach[3, "Pr(>F)"])),
  Cost = c(format_p(aov_edc[2, "Pr(>F)"]), format_p(aov_edc[1, "Pr(>F)"]), format_p(aov_edc[3, "Pr(>F)"]))
)

# --- 5. FINALIZE TABLE & RENDER ---
trt_order <- c("Corn", "Soy", "Sorghum", "Sorghum + Rye")

final_table <- bind_rows(table_body, source_var) |>
  mutate(
    order_helper = case_when(
      year == "2023" ~ 1, year == "2024" ~ 2,
      year == "2023-2024" ~ 3, year == "Source of Variation" ~ 4
    ),
    treatment_factor = factor(treatment, levels = c(trt_order, "Treatment", "Year", "Year × Treatment"))
  ) |>
  arrange(order_helper, treatment_factor) |>
  select(Year = year, Treatment = treatment, `N2O Loss` = N2O, `N Leaching` = Leach, `Env. Damage Cost` = Cost)

ft <- final_table |>
  gt() |>
  tab_header(title = md("**Table 3. Annual nitrogen losses and environmental costs**")) |>
  cols_label(
    `N2O Loss` = md("N<sub>2</sub>O Loss<br>(kg N ha<sup>-1</sup>)"),
    `N Leaching` = md("N Leaching<br>(kg N ha<sup>-1</sup>)"),
    `Env. Damage Cost` = md("Total Environmental Cost<br>(USD ha<sup>-1</sup>)")
  ) |>
  cols_align(align = "center", columns = -Treatment) |>
  tab_style(
    style = cell_borders(sides = "top", color = "gray", weight = px(2)),
    locations = cells_body(rows = Year == "Source of Variation")
  ) |>
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(rows = Year == "Source of Variation")
  ) |>
  tab_footnote(
    footnote = "Values are mean ± SD (3 significant figures). Letters indicate Tukey-adjusted groups within year/period (α=0.05). Costs: N₂O ($16.18/kg N) + Leaching ($18.54/kg N). Two-year totals for Corn/Soy estimated using variance propagation of annual crop phases."
  )
ft
# Save as RTF

gtsave(ft, "tables/table3_nitrogen_losses_environmental_costs.rtf")
```

```{r}
library(car) # For Levene's Test

# --- FUNCTION: CHECK ASSUMPTIONS ---
check_anova_assumptions <- function(data, col_name, label) {
  # 1. Fit the Global Model
  # We use the same model structure as your Table 3 footer
  model <- aov(as.formula(paste(col_name, "~ year * treatment")), data = data)
  
  # 2. Normality Test (Shapiro-Wilk on Residuals)
  # H0: Residuals are Normal. (We WANT p > 0.05)
  shapiro <- shapiro.test(residuals(model))
  
  # 3. Homogeneity of Variance (Levene's Test)
  # H0: Variances are Equal. (We WANT p > 0.05)
  # Note: using 'as.factor(year)' to treat year as a group
  levene <- leveneTest(as.formula(paste(col_name, "~ as.factor(year) * treatment")), data = data)
  
  # 4. Return Summary
  tibble(
    Variable = label,
    `Shapiro-Wilk P` = sprintf("%.3f", shapiro$p.value),
    `Normality Verdict` = ifelse(shapiro$p.value > 0.05, "PASS", "FAIL (Transform?)"),
    `Levene P` = sprintf("%.3f", levene$`Pr(>F)`[1]),
    `Homogeneity Verdict` = ifelse(levene$`Pr(>F)`[1] > 0.05, "PASS", "FAIL (Weighted LS?)")
  )
}

# --- RUN CHECKS ON ALL 3 VARIABLES ---
# We use 'plot_economics' because that is the real data used for the global ANOVA
assumptions_table <- bind_rows(
  check_anova_assumptions(plot_economics, "n2o_kg_ha", "N2O Loss"),
  check_anova_assumptions(plot_economics, "leaching_kg_ha", "N Leaching"),
  check_anova_assumptions(plot_economics, "edc_dollars", "Env. Damage Cost")
)

# Print the Table
print(assumptions_table)
```

```{r}
library(dplyr)
library(tidyr)
library(gt)
library(emmeans)
library(multcomp)

# --- 1. PREPARE PLOT-LEVEL DATA (With Row/Interrow Averaging) ---
n2o_plot <- interpolated_flux_data |>
  group_by(plot, treatment, year, date) |>
  summarise(daily_plot_flux = mean(interpolated_flux, na.rm = TRUE), .groups = "drop") |>
  group_by(plot, treatment, year) |>
  summarise(n2o_kg_ha = sum(daily_plot_flux, na.rm = TRUE) / 1000, .groups = "drop")

leach_plot <- annual_leaching |>
  select(year, plot, treatment, leaching_kg_ha = annual_cumulative_leaching)

plot_economics <- n2o_plot |>
  inner_join(leach_plot, by = c("year", "plot", "treatment")) |>
  mutate(edc_dollars = (n2o_kg_ha * 16.18) + (leaching_kg_ha * 18.54))

# --- 2. CALCULATE 2-YEAR TOTALS (Method of Moments) ---
continuous_2year <- plot_economics |>
  filter(year %in% c(2023, 2024), treatment %in% c("Sorghum", "Sorghum + Rye")) |>
  group_by(plot, treatment) |>
  summarise(
    n2o_kg_ha = sum(n2o_kg_ha, na.rm = TRUE),
    leaching_kg_ha = sum(leaching_kg_ha, na.rm = TRUE),
    edc_dollars = sum(edc_dollars, na.rm = TRUE),
    count = n(), .groups = "drop"
  ) |> filter(count == 2) |> select(-count)

rotation_annual_stats <- plot_economics |>
  filter(year %in% c(2023, 2024), treatment %in% c("Corn", "Soy")) |>
  group_by(treatment, year) |>
  summarise(
    mu_n2o = mean(n2o_kg_ha, na.rm = TRUE), var_n2o = var(n2o_kg_ha, na.rm = TRUE),
    mu_leach = mean(leaching_kg_ha, na.rm = TRUE), var_leach = var(leaching_kg_ha, na.rm = TRUE),
    mu_edc = mean(edc_dollars, na.rm = TRUE), var_edc = var(edc_dollars, na.rm = TRUE),
    .groups = "drop"
  )

rotation_2year_stats <- rotation_annual_stats |>
  group_by(treatment) |>
  summarise(
    final_mu_n2o = sum(mu_n2o), final_sd_n2o = sqrt(sum(var_n2o)),
    final_mu_leach = sum(mu_leach), final_sd_leach = sqrt(sum(var_leach)),
    final_mu_edc = sum(mu_edc), final_sd_edc = sqrt(sum(var_edc)), .groups = "drop"
  )

rotation_synthetic_plots <- rotation_2year_stats |>
  group_by(treatment) |>
  group_modify(~ {
    n_sim <- 3
    make_dist <- function(n, mu, sd) {
      x <- rnorm(n)
      if(sd > 0) x_final <- ((x - mean(x)) / sd(x)) * sd + mu else x_final <- rep(mu, n)
      return(pmax(0, x_final))
    }
    tibble(
      plot = paste0("Syn_", 1:n_sim),
      n2o_kg_ha = make_dist(n_sim, .x$final_mu_n2o, .x$final_sd_n2o),
      leaching_kg_ha = make_dist(n_sim, .x$final_mu_leach, .x$final_sd_leach),
      edc_dollars = make_dist(n_sim, .x$final_mu_edc, .x$final_sd_edc)
    )
  }) |> ungroup()

final_2year_data <- bind_rows(continuous_2year, rotation_synthetic_plots) |> mutate(year = "2023-2024")

stats_input_data <- bind_rows(plot_economics |> mutate(year = as.character(year)), final_2year_data)

# --- 3. STATISTICAL LOOP (TRANSFORMED STATS, REAL MEANS) ---

calc_stat_column <- function(data, col_name, is_money = FALSE) {
  # DECISION: Log-transform for Leaching and Cost, Raw for N2O
  if (col_name %in% c("leaching_kg_ha", "edc_dollars")) {
    f <- as.formula(paste("log10(", col_name, " + 1) ~ treatment"))
  } else {
    f <- as.formula(paste(col_name, "~ treatment"))
  }
  
  fit <- lm(f, data = data)
  
  # Get Letters (based on the TRANSFORMED model)
  lets <- tryCatch({
    emmeans(fit, ~ treatment) |>
      cld(adjust = "tukey", Letters = letters, alpha = 0.05) |>
      as_tibble() |>
      mutate(letter = trimws(.group)) |>
      select(treatment, letter)
  }, error = function(e) tibble(treatment = unique(data$treatment), letter = ""))
  
  # Get Summary Stats (Arithmetic Mean/SD for display)
  data |>
    group_by(treatment) |>
    summarise(mean = mean(.data[[col_name]], na.rm = TRUE), sd = sd(.data[[col_name]], na.rm = TRUE), .groups = "drop") |>
    left_join(lets, by = "treatment") |>
    mutate(
      mean_str = formatC(signif(mean, 3), digits = 3, format = "fg", flag = "#"),
      sd_str = formatC(signif(sd, 3), digits = 3, format = "fg", flag = "#"),
      mean_str = sub("\\.$", "", mean_str),
      sd_str = sub("\\.$", "", sd_str),
      result_str = if(is_money) sprintf("$%s \u00B1 %s (%s)", mean_str, sd_str, letter) else sprintf("%s \u00B1 %s (%s)", mean_str, sd_str, letter)
    ) |>
    select(treatment, result_str)
}

table_body <- stats_input_data |>
  group_by(year) |>
  group_modify(~ {
    n2o <- calc_stat_column(.x, "n2o_kg_ha")
    leach <- calc_stat_column(.x, "leaching_kg_ha")
    edc <- calc_stat_column(.x, "edc_dollars", is_money = TRUE)
    n2o |> rename(N2O = result_str) |>
      left_join(leach |> rename(Leach = result_str), by = "treatment") |>
      left_join(edc |> rename(Cost = result_str), by = "treatment")
  }) |> ungroup()

# --- 4. SOURCE OF VARIATION (Using Log Models where needed) ---
aov_n2o <- summary(aov(n2o_kg_ha ~ as.factor(year) * treatment, data = plot_economics))[[1]]
aov_leach <- summary(aov(log10(leaching_kg_ha+1) ~ as.factor(year) * treatment, data = plot_economics))[[1]]
aov_edc <- summary(aov(log10(edc_dollars+1) ~ as.factor(year) * treatment, data = plot_economics))[[1]]

format_p <- function(p) ifelse(p < 0.001, "< 0.001", sprintf("%.3f", p))

source_var <- tibble(
  year = "Source of Variation",
  treatment = c("Treatment", "Year", "Year × Treatment"),
  N2O = c(format_p(aov_n2o[2, "Pr(>F)"]), format_p(aov_n2o[1, "Pr(>F)"]), format_p(aov_n2o[3, "Pr(>F)"])),
  Leach = c(format_p(aov_leach[2, "Pr(>F)"]), format_p(aov_leach[1, "Pr(>F)"]), format_p(aov_leach[3, "Pr(>F)"])),
  Cost = c(format_p(aov_edc[2, "Pr(>F)"]), format_p(aov_edc[1, "Pr(>F)"]), format_p(aov_edc[3, "Pr(>F)"]))
)

# --- 5. FINALIZE ---
trt_order <- c("Corn", "Soy", "Sorghum", "Sorghum + Rye")
final_table <- bind_rows(table_body, source_var) |>
  mutate(
    order_helper = case_when(year == "2023" ~ 1, year == "2024" ~ 2, year == "2023-2024" ~ 3, year == "Source of Variation" ~ 4),
    treatment_factor = factor(treatment, levels = c(trt_order, "Treatment", "Year", "Year × Treatment"))
  ) |>
  arrange(order_helper, treatment_factor) |>
  select(Year = year, Treatment = treatment, `N2O Loss` = N2O, `N Leaching` = Leach, `Env. Damage Cost` = Cost)

final_table |> gt() |>
  tab_header(title = md("**Table 3. Annual nitrogen losses and environmental costs**")) |>
  cols_label(`N2O Loss` = md("N<sub>2</sub>O Loss<br>(kg N ha<sup>-1</sup>)"), `N Leaching` = md("N Leaching<br>(kg N ha<sup>-1</sup>)"), `Env. Damage Cost` = md("Total Environmental Cost<br>(USD ha<sup>-1</sup>)")) |>
  cols_align(align = "center", columns = -Treatment) |>
  tab_style(style = cell_borders(sides = "top", color = "gray", weight = px(2)), locations = cells_body(rows = Year == "Source of Variation")) |>
  tab_style(style = cell_text(weight = "bold"), locations = cells_body(rows = Year == "Source of Variation")) |>
  tab_footnote(footnote = "Values are arithmetic mean ± SD (3 sig figs). Letters indicate Tukey-adjusted groups derived from log-transformed data for leaching/costs and non-transformed data for N2O (α=0.05).")
```

```{r}
# --- QUICK P-VALUE CHECKER (LEACHING) ---

# 1. Fit the Log-Transformed Model (Same as your Table 3)
fit_leach <- lm(log10(leaching_kg_ha + 1) ~ year * treatment, data = plot_economics)

# 2. Extract the Specific Contrasts (Sorghum vs. Sorghum + Rye)
library(emmeans)
contrasts <- emmeans(fit_leach, ~ treatment | year) |>
  contrast(method = "pairwise") |>
  as_tibble() |>
  filter(contrast == "Sorghum - (Sorghum + Rye)") |>
  select(year, contrast, p.value)

# 3. Print the Result
print(contrasts)
```


```{r}
library(tidyverse)
library(readxl)
library(patchwork) # For combining panels

# --- 1. LOAD & CLEAN TEXTURE DATA (Your Code) ---
# Note: Ensure the path to the Excel file is correct in your local environment
texture_raw <- read_excel("data/PSA Report - AGRON-McDaniel-Potter-2024.xlsm",
    sheet = "Main Data File format", n_max = 22
)

# Ensure leaching data is available (re-load if necessary)
if (!exists("leaching_data")) {
  leaching_data <- read_csv("data/clean_leaching.csv") |>
    janitor::clean_names() |>
    mutate(
      date = as.Date(date),
      year = year(date)
    ) |>
    filter(year %in% c(2023, 2024))
}

# Calculate annual cumulative nitrogen leaching per plot
plot_area_ft2 <- 120 * 160
plot_area_ha <- plot_area_ft2 / 107639.1041671

annual_leaching <- leaching_data |>
  mutate(plot = as.numeric(plot)) |>
  group_by(plot, treatment, year) |>
  summarise(
    # mg -> kg, then divide by hectares
    annual_cumulative_leaching = (max(cumulative_n_loss_mg, na.rm = TRUE) / 1e6) / plot_area_ha, 
    .groups = "drop",
    annual_drainage_l = max(cumulative_flow_l, na.rm = TRUE),
    annual_drainage_mm = (annual_drainage_l / plot_area_ha) / 10000
  ) |>
  filter(is.finite(annual_cumulative_leaching), annual_cumulative_leaching >= 0)

print(annual_leaching)

texture <- texture_raw %>%
    select(Sample, Sand = S, Silt = T, Clay = C) %>%
    separate(Sample, into = c("ID", "Plot"), sep = "_") %>%
    mutate(Plot = as.numeric(Plot)) %>%
    drop_na() %>%
    mutate(
        Sand = as.numeric(Sand),
        Silt = as.numeric(Silt),
        Clay = as.numeric(Clay)
    ) %>%
    select(Plot, Sand, Silt, Clay) # We only need Plot and Texture cols

# --- 2. JOIN WITH DRAINAGE & LEACHING DATA ---
# We use 'annual_leaching' from your previous analysis steps
# Ensure 'drainage_mm' is the correct column name for water volume in your dataset
plot_hydrology <- annual_leaching %>%
  # Select key vars. IF YOUR DRAINAGE COL IS NAMED DIFFERENTLY, CHANGE 'drainage_mm' BELOW
  select(year, plot, treatment, drainage_mm = annual_drainage_mm, leaching_kg_ha = annual_cumulative_leaching) %>% 
  left_join(texture, by = c("plot" = "Plot")) %>%
  mutate(
    year = as.factor(year),
    # Ensure treatment order for coloring
    treatment = factor(treatment, levels = c("Corn", "Soy", "Sorghum", "Sorghum + Rye"))
  )

# --- 3. GENERATE PLOTS ---

# PANEL A: Texture vs. Drainage (The "Site Characteristic" Check)
# Does sandier soil drain more? (Expect positive slope)
p_texture <- ggplot(plot_hydrology, aes(x = Sand, y = drainage_mm)) +
  geom_smooth(method = "lm", color = "black", fill = "grey80", alpha = 0.5) +
  geom_point(aes(fill = treatment), shape = 21, size = 3, color = "black", stroke = 0.5) +
  scale_fill_manual(values = c("Corn" = "#E69F00", "Soy" = "#D55E00", 
                               "Sorghum" = "grey70", "Sorghum + Rye" = "#009E73")) +
  labs(
    title = "A. Soil Texture vs. Drainage",
    x = "Sand Content (%)",
    y = "Annual Drainage (mm)"
  ) +
  theme_bw() +
  theme(legend.position = "none") # Hide legend here, show in Panel B

# PANEL B: Drainage vs. N Loss (The "Uncoupling" Effect)
# Does WCC break the link between water flow and N loss?
p_loss <- ggplot(plot_hydrology, aes(x = drainage_mm, y = leaching_kg_ha)) +
  # Add global trend line (dashed) to show the general "Water = Leaching" rule
  geom_smooth(method = "lm", se = FALSE, color = "grey60", linetype = "dashed") +
  # Add points
  geom_point(aes(fill = treatment, shape = treatment), size = 3.5, alpha = 0.9) +
  # Custom Colors & Shapes
  scale_fill_manual(values = c("Corn" = "#E69F00", "Soy" = "#D55E00", 
                               "Sorghum" = "grey70", "Sorghum + Rye" = "#009E73")) +
  scale_shape_manual(values = c(21, 24, 22, 21)) + # Circle, Triangle, Square, Circle
  labs(
    title = "B. Drainage vs. N Leaching Load",
    x = "Annual Drainage (mm)",
    y = expression(Annual~NO[3]-N~Leaching~(kg~N~ha^{-1})),
    fill = "Treatment",
    shape = "Treatment"
  ) +
  theme_bw() +
  theme(
    legend.position = "right",
    legend.box.background = element_rect(color = "black", linewidth = 0.5)
  )

# --- 4. COMBINE & SAVE ---
figure_4 <- p_texture + p_loss + 
  plot_layout(widths = c(1, 1.5)) # Give Panel B a bit more width

print(figure_4)
# ggsave("FigureS?_Hydrology.png", figure_4, width = 10, height = 5)
```


```{r}
library(tidyverse)

# 1. DEFINE CONSTANTS
plot_area_ft2 <- 120 * 160
plot_area_ha <- plot_area_ft2 / 107639.1041671

# 2. PREPARE DATA
# We use the raw 'leaching_data' (daily/weekly measurements)
hydrograph_data <- leaching_data %>%
  arrange(plot, date) %>%
  group_by(plot, year) %>% # Reset calculation for each year/plot combo
  mutate(
    # Convert Cumulative Liters -> mm Depth
    cumulative_mm = (cumulative_flow_l / plot_area_ha) / 10000,
    
    # Optional: If your data doesn't reset to 0 at Jan 1, create a "Yearly Cumulative"
    # This ensures every line starts at 0 for the graph
    cumulative_mm_reset = cumulative_mm - min(cumulative_mm, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(plot = as.factor(plot))

# 3. PLOT CUMULATIVE HYDROGRAPH
p_hydro <- ggplot(hydrograph_data, aes(x = date, y = cumulative_mm_reset, group = plot, color = treatment)) +
  # Draw lines for each plot
  geom_line(alpha = 0.8, size = 0.7) +
  
  # Split by Year to see seasonal differences clearly
  facet_wrap(~year, scales = "free_x") +
  
  # Colors
  scale_color_manual(values = c("Corn" = "#E69F00", 
                                "Soy" = "#D55E00", 
                                "Sorghum" = "grey70", 
                                "Sorghum + Rye" = "#009E73")) +
  
  # Labels
  labs(title = "Seasonal Cumulative Drainage Dynamics",
       subtitle = "Steep slopes indicate active drainage periods; flat lines indicate dry periods.",
       x = "Date",
       y = "Cumulative Drainage (mm)",
       color = "Treatment") +
  
  # Theme
  theme_bw() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

print(p_hydro)
```

```{r}
library(broom) # For nice summary tables

# --- TEST 1: The "Texture Driver" (For Panel A) ---
# Question: Does Sand % significantly predict Drainage?
# We use a Linear Model (lm).
tex_stats <- lm(drainage_mm ~ Sand, data = plot_hydrology)

print("--- TEXTURE VS DRAINAGE STATISTICS ---")
print(anova(tex_stats))
print(summary(tex_stats))
# Look for:
# 1. Multiple R-squared (The strength of the link)
# 2. P-value for 'Sand' (Is it significant?)


# --- TEST 2: The "Uncoupling" Effect (For Panel B) ---
# Question: Is the slope of Leaching vs. Drainage different for WCC?
# We use ANCOVA. The key is the INTERACTION term (*).
# Model: Leaching ~ Drainage + Treatment + (Drainage * Treatment)

# First, set "Sorghum + Rye" as the reference group to see if others differ from IT
plot_hydrology$treatment <- relevel(plot_hydrology$treatment, ref = "Sorghum + Rye")

uncouple_stats <- lm(leaching_kg_ha ~ drainage_mm * treatment, data = plot_hydrology)

print("--- UNCOUPLING STATISTICS (ANCOVA) ---")
print(anova(uncouple_stats)) 

# detailed coefficients to see specific slope differences
print(summary(uncouple_stats))
```